# 控制结构

## if 语句

### 基本语法

```go
if condition {
    // 代码块
}

if condition {
    // 代码块1
} else {
    // 代码块2
}

if condition1 {
    // 代码块1
} else if condition2 {
    // 代码块2
} else {
    // 代码块3
}
```

### 特殊语法：if 语句中的变量声明

```go
// 在 if 条件中声明变量（作用域仅在 if-else 块内）
if err := doSomething(); err != nil {
    fmt.Println("错误:", err)
}

// 等价于
err := doSomething()
if err != nil {
    fmt.Println("错误:", err)
}
```

**与其他语言对比**：
- **C++**: `if (condition) { }`，条件两侧需要括号
- **Rust**: `if condition { }`，类似但更严格
- **Java**: `if (condition) { }`，需要括号

**Go 特点**：
- 不需要括号（除非复杂表达式）
- 大括号必须，即使只有一行代码
- 可以在条件中声明变量

## switch 语句

### 基本语法

```go
switch value {
case val1:
    // 代码块1
case val2:
    // 代码块2
default:
    // 默认代码块
}
```

### 多值匹配

```go
switch value {
case 1, 2, 3:
    fmt.Println("小数字")
case 4, 5, 6:
    fmt.Println("中等数字")
default:
    fmt.Println("其他")
}
```

### 无表达式的 switch（类似 if-else）

```go
switch {
case x < 0:
    fmt.Println("负数")
case x == 0:
    fmt.Println("零")
default:
    fmt.Println("正数")
}
```

### fallthrough

```go
switch value {
case 1:
    fmt.Println("1")
    fallthrough  // 继续执行下一个 case
case 2:
    fmt.Println("2")
case 3:
    fmt.Println("3")
}
```

**与其他语言对比**：
- **C++**: `switch` 需要 `break`，否则会 fallthrough
- **Rust**: `match` 表达式，更强大
- **Java**: `switch` 需要 `break`，Java 14+ 支持表达式

**Go 特点**：
- 默认不 fallthrough（与 C 相反）
- 可以使用表达式
- 不需要 break

## for 循环

### 基本 for 循环

```go
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
```

### 类似 while 的循环

```go
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}
```

### 无限循环

```go
for {
    // 无限循环
    if condition {
        break
    }
}
```

### range 循环（遍历）

```go
// 遍历切片
slice := []int{1, 2, 3}
for index, value := range slice {
    fmt.Printf("索引: %d, 值: %d\n", index, value)
}

// 只获取值
for _, value := range slice {
    fmt.Println(value)
}

// 只获取索引
for index := range slice {
    fmt.Println(index)
}

// 遍历 map
m := map[string]int{"a": 1, "b": 2}
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// 遍历字符串（按 rune）
s := "Hello, 世界"
for i, r := range s {
    fmt.Printf("索引: %d, 字符: %c\n", i, r)
}
```

**与其他语言对比**：
- **C++**: `for (init; condition; post) { }`，以及基于范围的 `for (auto x : xs)`
- **Rust**: `for item in iter { }`，类似 range
- **Java**: `for (int i = 0; i < 10; i++) { }` 或增强 for 循环

**Go 特点**：
- 只有 `for` 一种循环语句
- `range` 关键字用于遍历
- 可以在循环中声明变量

## break 和 continue

```go
// break：跳出循环
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // 跳出循环
    }
    fmt.Println(i)
}

// continue：跳过本次循环
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // 跳过偶数
    }
    fmt.Println(i)
}

// 带标签的 break（跳出外层循环）
outer:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break outer  // 跳出外层循环
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}
```

## goto 语句

```go
func example() {
    i := 0
loop:
    if i < 10 {
        fmt.Println(i)
        i++
        goto loop
    }
}
```

**注意**：`goto` 不推荐使用，但在某些场景下有用（如错误处理）。

## 实际应用场景 Demo

### Demo 1: 成绩等级判断

```go
package main

import "fmt"

func getGrade(score float64) string {
    switch {
    case score >= 90:
        return "优秀"
    case score >= 80:
        return "良好"
    case score >= 70:
        return "中等"
    case score >= 60:
        return "及格"
    default:
        return "不及格"
    }
}

func main() {
    scores := []float64{95, 85, 75, 65, 55}
    
    for _, score := range scores {
        fmt.Printf("分数: %.0f, 等级: %s\n", score, getGrade(score))
    }
}
```

### Demo 2: 查找和过滤

```go
package main

import "fmt"

func findFirstEven(numbers []int) (int, bool) {
    for _, num := range numbers {
        if num%2 == 0 {
            return num, true
        }
    }
    return 0, false
}

func filterEven(numbers []int) []int {
    result := make([]int, 0)
    for _, num := range numbers {
        if num%2 == 0 {
            result = append(result, num)
        }
    }
    return result
}

func main() {
    numbers := []int{1, 3, 5, 2, 4, 6, 7, 8}
    
    // 查找第一个偶数
    if num, found := findFirstEven(numbers); found {
        fmt.Printf("第一个偶数: %d\n", num)
    }
    
    // 过滤所有偶数
    evens := filterEven(numbers)
    fmt.Printf("所有偶数: %v\n", evens)
}
```

### Demo 3: 二分查找

```go
package main

import "fmt"

func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1  // 未找到
}

func main() {
    arr := []int{1, 3, 5, 7, 9, 11, 13, 15}
    target := 7
    
    index := binarySearch(arr, target)
    if index != -1 {
        fmt.Printf("找到 %d，索引: %d\n", target, index)
    } else {
        fmt.Printf("未找到 %d\n", target)
    }
}
```

### Demo 4: 字符串处理工具

```go
package main

import (
    "fmt"
    "strings"
)

func countWords(text string) map[string]int {
    words := strings.Fields(strings.ToLower(text))
    count := make(map[string]int)
    
    for _, word := range words {
        // 移除标点符号
        word = strings.Trim(word, ".,!?;:")
        if word != "" {
            count[word]++
        }
    }
    
    return count
}

func findLongestWord(text string) string {
    words := strings.Fields(text)
    longest := ""
    
    for _, word := range words {
        if len(word) > len(longest) {
            longest = word
        }
    }
    
    return longest
}

func main() {
    text := "Go is a programming language. Go is simple and efficient!"
    
    fmt.Println("词频统计:")
    wordCount := countWords(text)
    for word, count := range wordCount {
        fmt.Printf("%s: %d\n", word, count)
    }
    
    fmt.Printf("\n最长单词: %s\n", findLongestWord(text))
}
```

### Demo 5: 质数判断和生成

```go
package main

import "fmt"

func isPrime(n int) bool {
    if n < 2 {
        return false
    }
    
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    
    return true
}

func generatePrimes(limit int) []int {
    primes := make([]int, 0)
    
    for i := 2; i <= limit; i++ {
        if isPrime(i) {
            primes = append(primes, i)
        }
    }
    
    return primes
}

func main() {
    // 判断单个数字
    numbers := []int{2, 3, 4, 17, 20, 29}
    for _, num := range numbers {
        fmt.Printf("%d 是质数: %v\n", num, isPrime(num))
    }
    
    // 生成质数列表
    fmt.Println("\n100 以内的质数:")
    primes := generatePrimes(100)
    for i, prime := range primes {
        fmt.Printf("%d ", prime)
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    fmt.Println()
}
```

### Demo 6: 菜单系统

```go
package main

import (
    "fmt"
    "os"
)

func showMenu() {
    fmt.Println("=== 菜单系统 ===")
    fmt.Println("1. 查看信息")
    fmt.Println("2. 修改信息")
    fmt.Println("3. 删除信息")
    fmt.Println("4. 退出")
    fmt.Print("请选择: ")
}

func main() {
    for {
        showMenu()
        
        var choice int
        fmt.Scanf("%d", &choice)
        
        switch choice {
        case 1:
            fmt.Println("查看信息功能")
        case 2:
            fmt.Println("修改信息功能")
        case 3:
            fmt.Println("删除信息功能")
        case 4:
            fmt.Println("退出程序")
            os.Exit(0)
        default:
            fmt.Println("无效选择，请重试")
        }
        
        fmt.Println()
    }
}
```

## 控制结构最佳实践

1. **if 语句**：
   - 优先使用 `if err != nil` 模式处理错误
   - 在条件中声明变量可以限制作用域

2. **switch 语句**：
   - 优先使用 `switch` 而不是多个 `if-else`
   - 利用默认不 fallthrough 的特性

3. **for 循环**：
   - 使用 `range` 遍历集合
   - 避免无限循环，确保有退出条件

4. **break/continue**：
   - 谨慎使用标签，保持代码可读性
   - 优先使用函数返回而不是复杂的 break

## 下一步

- [函数](./05-函数.md) - 学习函数定义和使用

