# 控制结构

## if 语句

### 基本语法

```go
if condition {
    // 代码块
}

if condition {
    // 代码块1
} else {
    // 代码块2
}

if condition1 {
    // 代码块1
} else if condition2 {
    // 代码块2
} else {
    // 代码块3
}
```

### 特殊语法：if 语句中的变量声明

```go
// 在 if 条件中声明变量（作用域仅在 if-else 块内）
if err := doSomething(); err != nil {
    fmt.Println("错误:", err)
}

// 等价于
err := doSomething()
if err != nil {
    fmt.Println("错误:", err)
}
```

**与其他语言对比**：
- **C++**: `if (condition) { }`，条件两侧需要括号
- **Rust**: `if condition { }`，类似但更严格
- **Java**: `if (condition) { }`，需要括号

**Go 特点**：
- 不需要括号（除非复杂表达式）
- 大括号必须，即使只有一行代码
- 可以在条件中声明变量

## switch 语句

### 基本语法

```go
switch value {
case val1:
    // 代码块1
case val2:
    // 代码块2
default:
    // 默认代码块
}
```

### 多值匹配

```go
switch value {
case 1, 2, 3:
    fmt.Println("小数字")
case 4, 5, 6:
    fmt.Println("中等数字")
default:
    fmt.Println("其他")
}
```

### 无表达式的 switch（类似 if-else）

```go
switch {
case x < 0:
    fmt.Println("负数")
case x == 0:
    fmt.Println("零")
default:
    fmt.Println("正数")
}
```

### fallthrough

```go
switch value {
case 1:
    fmt.Println("1")
    fallthrough  // 继续执行下一个 case
case 2:
    fmt.Println("2")
case 3:
    fmt.Println("3")
}
```

**与其他语言对比**：
- **C++**: `switch` 需要 `break`，否则会 fallthrough
- **Rust**: `match` 表达式，更强大
- **Java**: `switch` 需要 `break`，Java 14+ 支持表达式

**Go 特点**：
- 默认不 fallthrough（与 C 相反）
- 可以使用表达式
- 不需要 break

## for 循环

### 基本 for 循环

```go
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
```

### 类似 while 的循环

```go
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}
```

### 无限循环

```go
for {
    // 无限循环
    if condition {
        break
    }
}
```

### range 循环（遍历）

```go
// 遍历切片
slice := []int{1, 2, 3}
for index, value := range slice {
    fmt.Printf("索引: %d, 值: %d\n", index, value)
}

// 只获取值
for _, value := range slice {
    fmt.Println(value)
}

// 只获取索引
for index := range slice {
    fmt.Println(index)
}

// 遍历 map
m := map[string]int{"a": 1, "b": 2}
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// 遍历字符串（按 rune）
s := "Hello, 世界"
for i, r := range s {
    fmt.Printf("索引: %d, 字符: %c\n", i, r)
}
```

**与其他语言对比**：
- **C++**: `for (init; condition; post) { }`，以及基于范围的 `for (auto x : xs)`
- **Rust**: `for item in iter { }`，类似 range
- **Java**: `for (int i = 0; i < 10; i++) { }` 或增强 for 循环

**Go 特点**：
- 只有 `for` 一种循环语句
- `range` 关键字用于遍历
- 可以在循环中声明变量

## break 和 continue

```go
// break：跳出循环
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // 跳出循环
    }
    fmt.Println(i)
}

// continue：跳过本次循环
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // 跳过偶数
    }
    fmt.Println(i)
}

// 带标签的 break（跳出外层循环）
outer:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break outer  // 跳出外层循环
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}
```

## goto 语句

```go
func example() {
    i := 0
loop:
    if i < 10 {
        fmt.Println(i)
        i++
        goto loop
    }
}
```

**注意**：`goto` 不推荐使用，但在某些场景下有用（如错误处理）。

## 实际应用场景 Demo

### Demo 1: 成绩等级判断

```go
package main

import "fmt"

// getGrade 根据分数返回等级
func getGrade(score float64) string {
    // 使用无表达式的 switch（类似 if-else 链）
    switch {
    case score >= 90:
        return "优秀" // 90 分及以上
    case score >= 80:
        return "良好" // 80-89 分
    case score >= 70:
        return "中等" // 70-79 分
    case score >= 60:
        return "及格" // 60-69 分
    default:
        return "不及格" // 60 分以下
    }
}

func main() {
    // 测试不同分数
    scores := []float64{95, 85, 75, 65, 55}
    
    // 遍历每个分数并判断等级
    for _, score := range scores {
        fmt.Printf("分数: %.0f, 等级: %s\n", score, getGrade(score))
    }
}
```

### Demo 2: 查找和过滤

```go
package main

import "fmt"

// findFirstEven 查找第一个偶数
// 返回找到的偶数和是否找到的标志
func findFirstEven(numbers []int) (int, bool) {
    // 遍历数字切片
    for _, num := range numbers {
        // 使用取模运算判断是否为偶数（num % 2 == 0）
        if num%2 == 0 {
            // 找到第一个偶数，立即返回
            return num, true
        }
    }
    // 未找到，返回零值和 false
    return 0, false
}

// filterEven 过滤出所有偶数
func filterEven(numbers []int) []int {
    // 创建空切片用于存储结果
    result := make([]int, 0)
    // 遍历所有数字
    for _, num := range numbers {
        // 如果是偶数，添加到结果切片
        if num%2 == 0 {
            result = append(result, num)
        }
    }
    return result
}

func main() {
    numbers := []int{1, 3, 5, 2, 4, 6, 7, 8}
    
    // 查找第一个偶数（使用 if 语句中的短变量声明）
    if num, found := findFirstEven(numbers); found {
        fmt.Printf("第一个偶数: %d\n", num)
    }
    
    // 过滤所有偶数
    evens := filterEven(numbers)
    fmt.Printf("所有偶数: %v\n", evens)
}
```

### Demo 3: 二分查找

```go
package main

import "fmt"

// binarySearch 在已排序的数组中二分查找目标值
// 返回目标值的索引，未找到返回 -1
func binarySearch(arr []int, target int) int {
    // 初始化左右边界
    left, right := 0, len(arr)-1
    
    // 当左边界小于等于右边界时继续查找
    for left <= right {
        // 计算中间位置（避免溢出：left + (right-left)/2）
        mid := left + (right-left)/2
        
        if arr[mid] == target {
            // 找到目标值，返回索引
            return mid
        } else if arr[mid] < target {
            // 中间值小于目标，在右半部分查找
            left = mid + 1
        } else {
            // 中间值大于目标，在左半部分查找
            right = mid - 1
        }
    }
    
    return -1  // 未找到
}

func main() {
    // 注意：二分查找要求数组已排序
    arr := []int{1, 3, 5, 7, 9, 11, 13, 15}
    target := 7
    
    index := binarySearch(arr, target)
    if index != -1 {
        fmt.Printf("找到 %d，索引: %d\n", target, index)
    } else {
        fmt.Printf("未找到 %d\n", target)
    }
}
```

### Demo 4: 字符串处理工具

```go
package main

import (
    "fmt"
    "strings"
)

// countWords 统计文本中每个单词的出现次数
func countWords(text string) map[string]int {
    // 先转小写，再按空白字符分割成单词切片
    words := strings.Fields(strings.ToLower(text))
    // 创建 map 存储词频
    count := make(map[string]int)
    
    // 遍历每个单词
    for _, word := range words {
        // 移除标点符号（.,!?;:）
        word = strings.Trim(word, ".,!?;:")
        // 确保单词不为空（避免空字符串计数）
        if word != "" {
            count[word]++ // 计数加 1
        }
    }
    
    return count
}

// findLongestWord 查找文本中最长的单词
func findLongestWord(text string) string {
    // 按空白字符分割文本
    words := strings.Fields(text)
    longest := "" // 初始化为空字符串
    
    // 遍历所有单词
    for _, word := range words {
        // 如果当前单词长度大于已记录的最长单词
        if len(word) > len(longest) {
            longest = word // 更新最长单词
        }
    }
    
    return longest
}

func main() {
    text := "Go is a programming language. Go is simple and efficient!"
    
    fmt.Println("词频统计:")
    wordCount := countWords(text)
    // 遍历 map 输出词频
    for word, count := range wordCount {
        fmt.Printf("%s: %d\n", word, count)
    }
    
    fmt.Printf("\n最长单词: %s\n", findLongestWord(text))
}
```

### Demo 5: 质数判断和生成

```go
package main

import "fmt"

// isPrime 判断一个数是否为质数
func isPrime(n int) bool {
    // 小于 2 的数不是质数
    if n < 2 {
        return false
    }
    
    // 只需检查到 sqrt(n) 即可（优化：i*i <= n）
    for i := 2; i*i <= n; i++ {
        // 如果能被 i 整除，说明不是质数
        if n%i == 0 {
            return false
        }
    }
    
    return true
}

// generatePrimes 生成指定范围内的所有质数
func generatePrimes(limit int) []int {
    // 创建切片存储质数
    primes := make([]int, 0)
    
    // 从 2 开始检查到 limit
    for i := 2; i <= limit; i++ {
        if isPrime(i) {
            // 如果是质数，添加到切片
            primes = append(primes, i)
        }
    }
    
    return primes
}

func main() {
    // 判断单个数字是否为质数
    numbers := []int{2, 3, 4, 17, 20, 29}
    for _, num := range numbers {
        fmt.Printf("%d 是质数: %v\n", num, isPrime(num))
    }
    
    // 生成 100 以内的所有质数
    fmt.Println("\n100 以内的质数:")
    primes := generatePrimes(100)
    // 每 10 个质数换一行
    for i, prime := range primes {
        fmt.Printf("%d ", prime)
        if (i+1)%10 == 0 {
            fmt.Println() // 换行
        }
    }
    fmt.Println()
}
```

### Demo 6: 菜单系统

```go
package main

import (
    "fmt"
    "os"
)

// showMenu 显示菜单选项
func showMenu() {
    fmt.Println("=== 菜单系统 ===")
    fmt.Println("1. 查看信息")
    fmt.Println("2. 修改信息")
    fmt.Println("3. 删除信息")
    fmt.Println("4. 退出")
    fmt.Print("请选择: ")
}

func main() {
    // 无限循环，直到用户选择退出
    for {
        showMenu() // 显示菜单
        
        var choice int
        // 读取用户输入的选择
        fmt.Scanf("%d", &choice)
        
        // 根据用户选择执行相应操作
        switch choice {
        case 1:
            fmt.Println("查看信息功能")
        case 2:
            fmt.Println("修改信息功能")
        case 3:
            fmt.Println("删除信息功能")
        case 4:
            fmt.Println("退出程序")
            os.Exit(0) // 退出程序
        default:
            // 无效选择，提示用户重试
            fmt.Println("无效选择，请重试")
        }
        
        fmt.Println() // 空行分隔
    }
}
```

## 控制结构最佳实践

1. **if 语句**：
   - 优先使用 `if err != nil` 模式处理错误
   - 在条件中声明变量可以限制作用域

2. **switch 语句**：
   - 优先使用 `switch` 而不是多个 `if-else`
   - 利用默认不 fallthrough 的特性

3. **for 循环**：
   - 使用 `range` 遍历集合
   - 避免无限循环，确保有退出条件

4. **break/continue**：
   - 谨慎使用标签，保持代码可读性
   - 优先使用函数返回而不是复杂的 break

## 下一步

- [函数](./05-函数.md) - 学习函数定义和使用

