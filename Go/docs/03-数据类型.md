# 数据类型

## 基本类型

### 整数类型

```go
var i8  int8   = 127          // -128 到 127
var i16 int16  = 32767        // -32768 到 32767
var i32 int32  = 2147483647   // -2147483648 到 2147483647
var i64 int64  = 9223372036854775807

var u8  uint8   = 255         // 0 到 255
var u16 uint16  = 65535       // 0 到 65535
var u32 uint32  = 4294967295
var u64 uint64  = 18446744073709551615

var i int   // 32 或 64 位，取决于平台
var u uint  // 32 或 64 位，取决于平台

var b byte = 255  // uint8 的别名
var r rune = '中'  // int32 的别名，表示 Unicode 码点
```

**与其他语言对比**：
- **C++**: 有 `short`、`int`、`long` 等，位数依平台而定，也有 `std::int32_t` 等固定宽度类型
- **Rust**: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`
- **Java**: `byte`, `short`, `int`, `long`（有符号）

### 浮点数类型

```go
var f32 float32 = 3.14
var f64 float64 = 3.141592653589793
var f   float64 = 3.14  // 默认 float64
```

**与其他语言对比**：
- **C++**: `float`, `double`, `long double`
- **Rust**: `f32`, `f64`
- **Java**: `float`, `double`

### 布尔类型

```go
var b1 bool = true
var b2 bool = false
var b3 bool  // 零值为 false
```

**与其他语言对比**：
- **C++**: 有内建 `bool` 类型，但在旧代码中也常用 `int` 代替
- **Rust**: `bool`
- **Java**: `boolean`

### 字符串类型

```go
var s1 string = "Hello"
var s2 string = `多行
字符串`
var s3 string  // 零值为 ""
```

**字符串操作**：

```go
s := "Hello"
len(s)                    // 5（字节数，不是字符数）
s[0]                      // 'H'（byte 类型）
s[0:3]                    // "Hel"（切片）
s + " World"              // "Hello World"
strings.Contains(s, "ll") // true
strings.HasPrefix(s, "He") // true
```

**与其他语言对比**：
- **C++**: 既有 C 风格的 `char*` 字符串，也有 `std::string`
- **Rust**: `String` 和 `&str`
- **Java**: `String`（不可变）

## 复合类型

### 数组

```go
var arr1 [5]int                    // [0 0 0 0 0]
var arr2 = [5]int{1, 2, 3, 4, 5}   // [1 2 3 4 5]
var arr3 = [...]int{1, 2, 3}       // 自动推断长度
arr4 := [5]int{1: 10, 3: 30}       // [0 10 0 30 0]
```

**数组特点**：
- 长度固定
- 值类型（赋值会复制）
- 长度是类型的一部分

**与其他语言对比**：
- **C++**: `int arr[5]` 是固定长度数组，也会发生衰变为指针
- **Rust**: `[i32; 5]`，固定长度数组
- **Java**: 数组是引用类型

### 切片（Slice）

切片是 Go 中最重要的数据结构之一。

```go
var s1 []int                        // nil 切片
s2 := []int{1, 2, 3}                // 字面量
s3 := make([]int, 5)                // 长度为 5，容量为 5
s4 := make([]int, 5, 10)            // 长度为 5，容量为 10

arr := [5]int{1, 2, 3, 4, 5}
s5 := arr[1:3]                      // [2 3]，从数组创建切片
```

**切片操作**：

```go
s := []int{1, 2, 3}
s = append(s, 4)                    // [1 2 3 4]
s = append(s, 5, 6, 7)              // [1 2 3 4 5 6 7]
s2 := []int{8, 9}
s = append(s, s2...)                // [1 2 3 4 5 6 7 8 9]

len(s)                               // 长度
cap(s)                               // 容量

s[1:3]                               // [2 3]，切片切片
s[:3]                                // [1 2 3]
s[3:]                                // [4 5 6 7 8 9]
```

**与其他语言对比**：
- **C++**: `std::vector<T>`、`std::array<T, N>` 等容器
- **Rust**: `Vec<T>`，动态数组
- **Java**: `ArrayList<T>`，动态数组

### 映射（Map）

```go
var m1 map[string]int               // nil map
m2 := make(map[string]int)          // 空 map
m3 := map[string]int{               // 字面量
    "apple":  5,
    "banana": 3,
}
```

**Map 操作**：

```go
m := make(map[string]int)
m["apple"] = 5                      // 添加/更新
value := m["apple"]                 // 读取
value, ok := m["banana"]            // 检查是否存在
delete(m, "apple")                  // 删除

// 遍历
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}
```

**与其他语言对比**：
- **C++**: `std::map<K, V>`、`std::unordered_map<K, V>`
- **Rust**: `HashMap<K, V>`
- **Java**: `HashMap<K, V>`

### 结构体（Struct）

```go
type Person struct {
    Name string
    Age  int
}

p1 := Person{"Alice", 30}
p2 := Person{Name: "Bob", Age: 25}
p3 := Person{Name: "Charlie"}      // Age 为零值 0
```

**与其他语言对比**：
- **C++**: `struct`/`class`，支持成员函数和继承
- **Rust**: `struct`，类似但更强大
- **Java**: `class`，面向对象

## 指针

```go
var x int = 10
var p *int = &x                     // p 是指向 x 的指针
*p = 20                             // 通过指针修改值

// Go 指针特点：
// 1. 不支持指针运算
// 2. 没有空指针异常（nil 指针）
// 3. 自动垃圾回收
```

**与其他语言对比**：
- **C++**: 支持原始指针和指针运算，也有 `std::unique_ptr` 等智能指针
- **Rust**: 有所有权系统，更安全
- **Java**: 没有显式指针

## 类型转换

Go 要求显式类型转换。

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// 字符串转换
s := strconv.Itoa(42)               // "42"
i, _ := strconv.Atoi("42")          // 42
f, _ := strconv.ParseFloat("3.14", 64)
```

**与其他语言对比**：
- **C++**: 存在隐式转换和用户自定义转换运算符，可能带来隐式开销
- **Rust**: 显式转换，类型安全
- **Java**: 基本类型可隐式转换

## 类型断言

```go
var i interface{} = "hello"
s := i.(string)                     // 类型断言
s, ok := i.(string)                 // 安全类型断言

// 类型开关
switch v := i.(type) {
case int:
    fmt.Printf("整数: %d\n", v)
case string:
    fmt.Printf("字符串: %s\n", v)
default:
    fmt.Printf("未知类型\n")
}
```

## 实际应用场景 Demo

### Demo 1: 学生管理系统

```go
package main

import (
    "fmt"
    "sort"
)

type Student struct {
    ID    int
    Name  string
    Score float64
}

type StudentManager struct {
    students []Student
}

func NewStudentManager() *StudentManager {
    return &StudentManager{
        students: make([]Student, 0),
    }
}

func (sm *StudentManager) AddStudent(s Student) {
    sm.students = append(sm.students, s)
}

func (sm *StudentManager) FindByID(id int) *Student {
    for i := range sm.students {
        if sm.students[i].ID == id {
            return &sm.students[i]
        }
    }
    return nil
}

func (sm *StudentManager) SortByScore() {
    sort.Slice(sm.students, func(i, j int) bool {
        return sm.students[i].Score > sm.students[j].Score
    })
}

func (sm *StudentManager) PrintAll() {
    for _, s := range sm.students {
        fmt.Printf("ID: %d, 姓名: %s, 分数: %.2f\n", s.ID, s.Name, s.Score)
    }
}

func main() {
    sm := NewStudentManager()
    
    sm.AddStudent(Student{ID: 1, Name: "张三", Score: 85.5})
    sm.AddStudent(Student{ID: 2, Name: "李四", Score: 92.0})
    sm.AddStudent(Student{ID: 3, Name: "王五", Score: 78.5})
    
    fmt.Println("所有学生:")
    sm.PrintAll()
    
    fmt.Println("\n按分数排序:")
    sm.SortByScore()
    sm.PrintAll()
    
    fmt.Println("\n查找 ID=2 的学生:")
    s := sm.FindByID(2)
    if s != nil {
        fmt.Printf("找到: %s, 分数: %.2f\n", s.Name, s.Score)
    }
}
```

### Demo 2: 词频统计

```go
package main

import (
    "fmt"
    "strings"
)

func wordFrequency(text string) map[string]int {
    words := strings.Fields(text)
    freq := make(map[string]int)
    
    for _, word := range words {
        word = strings.ToLower(word)
        word = strings.Trim(word, ".,!?;:")
        freq[word]++
    }
    
    return freq
}

func main() {
    text := "Go is a programming language. Go is simple and efficient. Go is great!"
    
    freq := wordFrequency(text)
    
    fmt.Println("词频统计:")
    for word, count := range freq {
        fmt.Printf("%s: %d\n", word, count)
    }
}
```

### Demo 3: 数组和切片性能对比

```go
package main

import "fmt"

// 使用数组（值传递，会复制）
func processArray(arr [1000]int) {
    arr[0] = 999  // 修改不影响原数组
}

// 使用切片（引用传递）
func processSlice(slice []int) {
    if len(slice) > 0 {
        slice[0] = 999  // 修改会影响原切片
    }
}

func main() {
    // 数组示例
    arr := [1000]int{1, 2, 3}
    fmt.Printf("数组修改前: %d\n", arr[0])
    processArray(arr)
    fmt.Printf("数组修改后: %d\n", arr[0])  // 仍然是 1
    
    // 切片示例
    slice := []int{1, 2, 3}
    fmt.Printf("切片修改前: %d\n", slice[0])
    processSlice(slice)
    fmt.Printf("切片修改后: %d\n", slice[0])  // 变为 999
}
```

### Demo 4: 类型转换工具函数

```go
package main

import (
    "fmt"
    "strconv"
)

func convertToString(v interface{}) string {
    switch val := v.(type) {
    case int:
        return strconv.Itoa(val)
    case int64:
        return strconv.FormatInt(val, 10)
    case float64:
        return strconv.FormatFloat(val, 'f', -1, 64)
    case bool:
        return strconv.FormatBool(val)
    case string:
        return val
    default:
        return fmt.Sprintf("%v", val)
    }
}

func main() {
    values := []interface{}{42, 3.14, true, "hello", int64(100)}
    
    for _, v := range values {
        fmt.Printf("%v (%T) -> %s\n", v, v, convertToString(v))
    }
}
```

## 类型系统总结

1. **基本类型**：int, float, bool, string
2. **复合类型**：array, slice, map, struct
3. **指针**：支持但限制较多
4. **接口**：`interface{}` 可以表示任何类型
5. **类型转换**：必须显式转换
6. **零值**：每种类型都有零值

## 下一步

- [控制结构](./04-控制结构.md) - 学习条件语句和循环

