# 数据类型

## 基本类型

### 整数类型

```go
var i8  int8   = 127          // -128 到 127
var i16 int16  = 32767        // -32768 到 32767
var i32 int32  = 2147483647   // -2147483648 到 2147483647
var i64 int64  = 9223372036854775807

var u8  uint8   = 255         // 0 到 255
var u16 uint16  = 65535       // 0 到 65535
var u32 uint32  = 4294967295
var u64 uint64  = 18446744073709551615

var i int   // 32 或 64 位，取决于平台
var u uint  // 32 或 64 位，取决于平台

var b byte = 255  // uint8 的别名
var r rune = '中'  // int32 的别名，表示 Unicode 码点
```

**与其他语言对比**：
- **C++**: 有 `short`、`int`、`long` 等，位数依平台而定，也有 `std::int32_t` 等固定宽度类型
- **Rust**: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`
- **Java**: `byte`, `short`, `int`, `long`（有符号）

### 浮点数类型

```go
var f32 float32 = 3.14
var f64 float64 = 3.141592653589793
var f   float64 = 3.14  // 默认 float64
```

**与其他语言对比**：
- **C++**: `float`, `double`, `long double`
- **Rust**: `f32`, `f64`
- **Java**: `float`, `double`

### 布尔类型

```go
var b1 bool = true
var b2 bool = false
var b3 bool  // 零值为 false
```

**与其他语言对比**：
- **C++**: 有内建 `bool` 类型，但在旧代码中也常用 `int` 代替
- **Rust**: `bool`
- **Java**: `boolean`

### 字符串类型

```go
var s1 string = "Hello"
var s2 string = `多行
字符串`
var s3 string  // 零值为 ""
```

**字符串操作**：

```go
s := "Hello"
len(s)                    // 5（字节数，不是字符数）
s[0]                      // 'H'（byte 类型）
s[0:3]                    // "Hel"（切片）
s + " World"              // "Hello World"
strings.Contains(s, "ll") // true
strings.HasPrefix(s, "He") // true
```

**与其他语言对比**：
- **C++**: 既有 C 风格的 `char*` 字符串，也有 `std::string`
- **Rust**: `String` 和 `&str`
- **Java**: `String`（不可变）

## 复合类型

### 数组

```go
var arr1 [5]int                    // [0 0 0 0 0]
var arr2 = [5]int{1, 2, 3, 4, 5}   // [1 2 3 4 5]
var arr3 = [...]int{1, 2, 3}       // 自动推断长度
arr4 := [5]int{1: 10, 3: 30}       // [0 10 0 30 0]
```

**数组特点**：
- 长度固定
- 值类型（赋值会复制）
- 长度是类型的一部分

**与其他语言对比**：
- **C++**: `int arr[5]` 是固定长度数组，也会发生衰变为指针
- **Rust**: `[i32; 5]`，固定长度数组
- **Java**: 数组是引用类型

### 切片（Slice）

切片是 Go 中最重要的数据结构之一。

```go
var s1 []int                        // nil 切片
s2 := []int{1, 2, 3}                // 字面量
s3 := make([]int, 5)                // 长度为 5，容量为 5
s4 := make([]int, 5, 10)            // 长度为 5，容量为 10

arr := [5]int{1, 2, 3, 4, 5}
s5 := arr[1:3]                      // [2 3]，从数组创建切片
```

**切片操作**：

```go
s := []int{1, 2, 3}
s = append(s, 4)                    // [1 2 3 4]
s = append(s, 5, 6, 7)              // [1 2 3 4 5 6 7]
s2 := []int{8, 9}
s = append(s, s2...)                // [1 2 3 4 5 6 7 8 9]

len(s)                               // 长度
cap(s)                               // 容量

s[1:3]                               // [2 3]，切片切片
s[:3]                                // [1 2 3]
s[3:]                                // [4 5 6 7 8 9]
```

**与其他语言对比**：
- **C++**: `std::vector<T>`、`std::array<T, N>` 等容器
- **Rust**: `Vec<T>`，动态数组
- **Java**: `ArrayList<T>`，动态数组

### 映射（Map）

```go
var m1 map[string]int               // nil map
m2 := make(map[string]int)          // 空 map
m3 := map[string]int{               // 字面量
    "apple":  5,
    "banana": 3,
}
```

**Map 操作**：

```go
m := make(map[string]int)
m["apple"] = 5                      // 添加/更新
value := m["apple"]                 // 读取
value, ok := m["banana"]            // 检查是否存在
delete(m, "apple")                  // 删除

// 遍历
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}
```

**与其他语言对比**：
- **C++**: `std::map<K, V>`、`std::unordered_map<K, V>`
- **Rust**: `HashMap<K, V>`
- **Java**: `HashMap<K, V>`

### 结构体（Struct）

```go
type Person struct {
    Name string
    Age  int
}

p1 := Person{"Alice", 30}
p2 := Person{Name: "Bob", Age: 25}
p3 := Person{Name: "Charlie"}      // Age 为零值 0
```

**与其他语言对比**：
- **C++**: `struct`/`class`，支持成员函数和继承
- **Rust**: `struct`，类似但更强大
- **Java**: `class`，面向对象

## 指针

```go
var x int = 10
var p *int = &x                     // p 是指向 x 的指针
*p = 20                             // 通过指针修改值

// Go 指针特点：
// 1. 不支持指针运算
// 2. 没有空指针异常（nil 指针）
// 3. 自动垃圾回收
```

**与其他语言对比**：
- **C++**: 支持原始指针和指针运算，也有 `std::unique_ptr` 等智能指针
- **Rust**: 有所有权系统，更安全
- **Java**: 没有显式指针

## 类型转换

Go 要求显式类型转换。

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// 字符串转换
s := strconv.Itoa(42)               // "42"
i, _ := strconv.Atoi("42")          // 42
f, _ := strconv.ParseFloat("3.14", 64)
```

**与其他语言对比**：
- **C++**: 存在隐式转换和用户自定义转换运算符，可能带来隐式开销
- **Rust**: 显式转换，类型安全
- **Java**: 基本类型可隐式转换

## 类型断言

```go
var i interface{} = "hello"
s := i.(string)                     // 类型断言
s, ok := i.(string)                 // 安全类型断言

// 类型开关
switch v := i.(type) {
case int:
    fmt.Printf("整数: %d\n", v)
case string:
    fmt.Printf("字符串: %s\n", v)
default:
    fmt.Printf("未知类型\n")
}
```

## 实际应用场景 Demo

### Demo 1: 学生管理系统

```go
package main

import (
    "fmt"
    "sort"
)

// Student 结构体：定义学生信息
type Student struct {
    ID    int     // 学生 ID
    Name  string  // 学生姓名
    Score float64 // 学生分数
}

// StudentManager 结构体：管理学生列表
type StudentManager struct {
    students []Student // 学生切片（动态数组）
}

// NewStudentManager 创建新的学生管理器（构造函数）
func NewStudentManager() *StudentManager {
    return &StudentManager{
        students: make([]Student, 0), // 初始化空切片
    }
}

// AddStudent 添加学生到管理器
func (sm *StudentManager) AddStudent(s Student) {
    // 使用 append 向切片追加元素
    sm.students = append(sm.students, s)
}

// FindByID 根据 ID 查找学生
func (sm *StudentManager) FindByID(id int) *Student {
    // 遍历学生列表
    for i := range sm.students {
        if sm.students[i].ID == id {
            // 返回找到的学生的指针
            return &sm.students[i]
        }
    }
    return nil // 未找到返回 nil
}

// SortByScore 按分数从高到低排序
func (sm *StudentManager) SortByScore() {
    // 使用 sort.Slice 自定义排序规则
    sort.Slice(sm.students, func(i, j int) bool {
        // 返回 true 表示 i 应该在 j 前面（分数高的在前）
        return sm.students[i].Score > sm.students[j].Score
    })
}

// PrintAll 打印所有学生信息
func (sm *StudentManager) PrintAll() {
    // 使用 range 遍历切片
    for _, s := range sm.students {
        fmt.Printf("ID: %d, 姓名: %s, 分数: %.2f\n", s.ID, s.Name, s.Score)
    }
}

func main() {
    // 创建学生管理器
    sm := NewStudentManager()
    
    // 添加学生（使用结构体字面量）
    sm.AddStudent(Student{ID: 1, Name: "张三", Score: 85.5})
    sm.AddStudent(Student{ID: 2, Name: "李四", Score: 92.0})
    sm.AddStudent(Student{ID: 3, Name: "王五", Score: 78.5})
    
    fmt.Println("所有学生:")
    sm.PrintAll()
    
    fmt.Println("\n按分数排序:")
    sm.SortByScore() // 排序
    sm.PrintAll()
    
    fmt.Println("\n查找 ID=2 的学生:")
    s := sm.FindByID(2)
    if s != nil {
        fmt.Printf("找到: %s, 分数: %.2f\n", s.Name, s.Score)
    }
}
```

### Demo 2: 词频统计

```go
package main

import (
    "fmt"
    "strings"
)

// wordFrequency 统计文本中每个单词的出现频率
func wordFrequency(text string) map[string]int {
    // strings.Fields 按空白字符分割文本为单词切片
    words := strings.Fields(text)
    // 创建 map 用于存储词频（key: 单词, value: 出现次数）
    freq := make(map[string]int)
    
    // 遍历每个单词
    for _, word := range words {
        // 转换为小写（统一格式）
        word = strings.ToLower(word)
        // 去除标点符号（.,!?;:）
        word = strings.Trim(word, ".,!?;:")
        // map 中对应单词的计数加 1
        // 如果 key 不存在，会自动初始化为零值 0，然后加 1
        freq[word]++
    }
    
    return freq
}

func main() {
    text := "Go is a programming language. Go is simple and efficient. Go is great!"
    
    // 统计词频
    freq := wordFrequency(text)
    
    fmt.Println("词频统计:")
    // 遍历 map，输出每个单词及其出现次数
    for word, count := range freq {
        fmt.Printf("%s: %d\n", word, count)
    }
}
```

### Demo 3: 数组和切片性能对比

```go
package main

import "fmt"

// 使用数组（值传递，会复制整个数组）
// 注意：数组长度是类型的一部分，[1000]int 是固定类型
func processArray(arr [1000]int) {
    arr[0] = 999  // 修改的是副本，不影响原数组
}

// 使用切片（引用传递，只传递切片头）
// 切片包含指向底层数组的指针、长度和容量
func processSlice(slice []int) {
    if len(slice) > 0 {
        slice[0] = 999  // 修改会影响原切片（共享底层数组）
    }
}

func main() {
    // 数组示例：数组是值类型，传递时会复制
    arr := [1000]int{1, 2, 3} // 前三个元素为 1,2,3，其余为 0
    fmt.Printf("数组修改前: %d\n", arr[0])
    processArray(arr) // 传递数组副本
    fmt.Printf("数组修改后: %d\n", arr[0])  // 仍然是 1（原数组未改变）
    
    // 切片示例：切片是引用类型，传递时共享底层数组
    slice := []int{1, 2, 3}
    fmt.Printf("切片修改前: %d\n", slice[0])
    processSlice(slice) // 传递切片引用
    fmt.Printf("切片修改后: %d\n", slice[0])  // 变为 999（原切片被修改）
}
```

### Demo 4: 类型转换工具函数

```go
package main

import (
    "fmt"
    "strconv"
)

// convertToString 将任意类型转换为字符串
// interface{} 可以接受任何类型
func convertToString(v interface{}) string {
    // 类型开关（type switch）：根据实际类型进行不同处理
    switch val := v.(type) {
    case int:
        // int 转字符串
        return strconv.Itoa(val)
    case int64:
        // int64 转字符串，10 表示十进制
        return strconv.FormatInt(val, 10)
    case float64:
        // float64 转字符串
        // 'f' 表示普通格式，-1 表示自动精度，64 表示 float64
        return strconv.FormatFloat(val, 'f', -1, 64)
    case bool:
        // bool 转字符串（"true" 或 "false"）
        return strconv.FormatBool(val)
    case string:
        // 已经是字符串，直接返回
        return val
    default:
        // 其他类型使用 fmt.Sprintf 的 %v 格式化
        return fmt.Sprintf("%v", val)
    }
}

func main() {
    // 创建包含不同类型元素的切片（使用 interface{}）
    values := []interface{}{42, 3.14, true, "hello", int64(100)}
    
    // 遍历并转换每个值
    for _, v := range values {
        // %v 显示值，%T 显示类型
        fmt.Printf("%v (%T) -> %s\n", v, v, convertToString(v))
    }
}
```

## 类型系统总结

1. **基本类型**：int, float, bool, string
2. **复合类型**：array, slice, map, struct
3. **指针**：支持但限制较多
4. **接口**：`interface{}` 可以表示任何类型
5. **类型转换**：必须显式转换
6. **零值**：每种类型都有零值

## 下一步

- [控制结构](./04-控制结构.md) - 学习条件语句和循环

