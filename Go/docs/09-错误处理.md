# 错误处理

## Error 接口

Go 使用 `error` 接口表示错误。

```go
type error interface {
    Error() string
}
```

### 创建错误

```go
import "errors"

err := errors.New("发生了错误")
fmt.Println(err.Error())  // 发生了错误
```

### 格式化错误

```go
import "fmt"

err := fmt.Errorf("用户 %s 不存在", username)
```

**与其他语言对比**：
- **C++**: 既可以使用返回值/错误码，也广泛使用异常机制 `try/catch`
- **Rust**: `Result<T, E>` 类型，更安全
- **Java**: `Exception` 类，使用 try-catch

**Go 特点**：
- 错误是值，不是异常
- 显式错误处理
- 没有 try-catch

## 错误处理模式

### 基本模式

```go
result, err := doSomething()
if err != nil {
    // 处理错误
    return err
}
// 使用 result
```

### 多返回值

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为0")
    }
    return a / b, nil
}

// 使用
result, err := divide(10, 2)
if err != nil {
    fmt.Printf("错误: %v\n", err)
    return
}
fmt.Printf("结果: %.2f\n", result)
```

### 错误包装

Go 1.13+ 支持错误包装。

```go
import "fmt"

func readFile(filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("读取文件失败: %w", err)  // %w 包装错误
    }
    // ...
    return nil
}
```

### 错误检查

```go
import "errors"

if errors.Is(err, os.ErrNotExist) {
    // 文件不存在
}

var pathErr *os.PathError
if errors.As(err, &pathErr) {
    // 是 PathError 类型
    fmt.Println(pathErr.Path)
}
```

## 自定义错误类型

```go
type MyError struct {
    Code    int
    Message string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("错误代码 %d: %s", e.Code, e.Message)
}

func doSomething() error {
    return &MyError{
        Code:    404,
        Message: "资源未找到",
    }
}
```

## 实际应用场景 Demo

### Demo 1: 文件操作错误处理

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
)

// readFileContent 读取文件内容（演示错误包装）
func readFileContent(filename string) (string, error) {
    // 打开文件
    file, err := os.Open(filename)
    if err != nil {
        // 使用 %w 包装错误，保留原始错误信息
        return "", fmt.Errorf("打开文件失败: %w", err)
    }
    defer file.Close() // 确保文件关闭
    
    // 读取文件内容
    content, err := ioutil.ReadAll(file)
    if err != nil {
        // 包装错误，添加上下文信息
        return "", fmt.Errorf("读取文件失败: %w", err)
    }
    
    return string(content), nil
}

// writeFileContent 写入文件内容（演示错误包装）
func writeFileContent(filename, content string) error {
    // 创建文件
    file, err := os.Create(filename)
    if err != nil {
        return fmt.Errorf("创建文件失败: %w", err)
    }
    defer file.Close() // 确保文件关闭
    
    // 写入内容
    _, err = file.WriteString(content)
    if err != nil {
        return fmt.Errorf("写入文件失败: %w", err)
    }
    
    return nil
}

func main() {
    // 读取文件
    content, err := readFileContent("test.txt")
    if err != nil {
        fmt.Printf("读取失败: %v\n", err)
        // 可以继续处理或返回
    } else {
        fmt.Printf("文件内容: %s\n", content)
    }
    
    // 写入文件
    err = writeFileContent("output.txt", "Hello, Go!")
    if err != nil {
        fmt.Printf("写入失败: %v\n", err)
    } else {
        fmt.Println("写入成功")
    }
}
```

### Demo 2: 网络请求错误处理

```go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
)

// HTTPError 自定义 HTTP 错误类型
type HTTPError struct {
    StatusCode int    // HTTP 状态码
    URL        string // 请求的 URL
}

// Error 实现 error 接口
func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.URL)
}

// fetchURL 获取 URL 内容（演示自定义错误类型）
func fetchURL(url string, timeout time.Duration) ([]byte, error) {
    // 创建带超时的 HTTP 客户端
    client := &http.Client{
        Timeout: timeout,
    }
    
    // 发送 HTTP GET 请求
    resp, err := client.Get(url)
    if err != nil {
        return nil, fmt.Errorf("请求失败: %w", err) // 包装网络错误
    }
    defer resp.Body.Close() // 确保响应体关闭
    
    // 检查 HTTP 状态码
    if resp.StatusCode != http.StatusOK {
        // 返回自定义错误类型
        return nil, &HTTPError{
            StatusCode: resp.StatusCode,
            URL:        url,
        }
    }
    
    // 读取响应体
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("读取响应失败: %w", err)
    }
    
    return body, nil
}

func main() {
    url := "https://api.github.com/users/octocat"
    
    data, err := fetchURL(url, time.Second*5)
    if err != nil {
        if httpErr, ok := err.(*HTTPError); ok {
            fmt.Printf("HTTP 错误: %v\n", httpErr)
        } else {
            fmt.Printf("请求错误: %v\n", err)
        }
        return
    }
    
    fmt.Printf("响应长度: %d 字节\n", len(data))
}
```

### Demo 3: 数据库操作错误处理

```go
package main

import (
    "errors"
    "fmt"
)

// 定义错误变量（使用 errors.New 创建）
// 这样可以进行错误比较：err == ErrNotFound
var (
    ErrNotFound     = errors.New("记录未找到")
    ErrInvalidInput = errors.New("无效输入")
    ErrDuplicateKey = errors.New("重复键")
)

// User 用户结构体
type User struct {
    ID   int    // 用户 ID
    Name string // 用户名称
}

// UserRepository 用户仓库（模拟数据库操作）
type UserRepository struct {
    users map[int]*User // 使用 map 存储用户（key: ID, value: User）
}

// NewUserRepository 创建用户仓库
func NewUserRepository() *UserRepository {
    return &UserRepository{
        users: make(map[int]*User),
    }
}

// Create 创建用户
func (r *UserRepository) Create(user *User) error {
    // 验证输入
    if user.Name == "" {
        return ErrInvalidInput // 返回预定义的错误
    }
    
    // 检查是否已存在
    if _, exists := r.users[user.ID]; exists {
        return ErrDuplicateKey
    }
    
    r.users[user.ID] = user
    return nil
}

// FindByID 根据 ID 查找用户
func (r *UserRepository) FindByID(id int) (*User, error) {
    user, exists := r.users[id]
    if !exists {
        return nil, ErrNotFound // 返回预定义的错误
    }
    return user, nil
}

// Update 更新用户
func (r *UserRepository) Update(user *User) error {
    // 检查用户是否存在
    if _, exists := r.users[user.ID]; !exists {
        return ErrNotFound
    }
    
    // 验证输入
    if user.Name == "" {
        return ErrInvalidInput
    }
    
    r.users[user.ID] = user
    return nil
}

func main() {
    repo := NewUserRepository()
    
    // 创建用户
    user := &User{ID: 1, Name: "Alice"}
    if err := repo.Create(user); err != nil {
        if err == ErrDuplicateKey {
            fmt.Println("用户已存在")
        } else {
            fmt.Printf("创建失败: %v\n", err)
        }
    }
    
    // 查找用户
    found, err := repo.FindByID(1)
    if err != nil {
        if err == ErrNotFound {
            fmt.Println("用户不存在")
        } else {
            fmt.Printf("查找失败: %v\n", err)
        }
    } else {
        fmt.Printf("找到用户: %+v\n", found)
    }
    
    // 查找不存在的用户
    _, err = repo.FindByID(999)
    if errors.Is(err, ErrNotFound) {
        fmt.Println("用户 999 不存在")
    }
}
```

### Demo 4: 错误链和上下文

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

// readConfig 读取配置文件（演示错误链的第一层）
func readConfig() error {
    filename := "config.json"
    
    file, err := os.Open(filename)
    if err != nil {
        // 使用 %w 包装错误，形成错误链
        return fmt.Errorf("打开配置文件失败: %w", err)
    }
    defer file.Close()
    
    // 模拟读取配置
    data := make([]byte, 100)
    _, err = file.Read(data)
    if err != nil {
        // 继续包装错误
        return fmt.Errorf("读取配置内容失败: %w", err)
    }
    
    return nil
}

// validateConfig 验证配置（演示错误链的第二层）
func validateConfig() error {
    err := readConfig()
    if err != nil {
        // 继续包装错误，形成错误链
        return fmt.Errorf("配置验证失败: %w", err)
    }
    return nil
}

// initializeApp 初始化应用（演示错误链的第三层）
func initializeApp() error {
    err := validateConfig()
    if err != nil {
        // 继续包装错误，形成完整的错误链
        return fmt.Errorf("应用初始化失败: %w", err)
    }
    return nil
}

func main() {
    err := initializeApp()
    if err != nil {
        fmt.Printf("错误: %v\n", err)
        fmt.Printf("错误链:\n")
        
        // 检查错误链
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("  原因: 文件不存在")
        }
        
        // 展开错误链
        for err != nil {
            fmt.Printf("  - %v\n", err)
            err = errors.Unwrap(err)
        }
    }
}
```

### Demo 5: 重试机制

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

// ErrTemporary 临时错误（可以重试的错误）
var ErrTemporary = errors.New("临时错误")

// unreliableOperation 模拟不可靠的操作（随机失败）
func unreliableOperation() error {
    // 模拟随机失败：当前时间戳能被 3 整除时失败
    if time.Now().Unix()%3 == 0 {
        return ErrTemporary
    }
    return nil
}

// retryOperation 带重试机制的操作执行
// operation: 要执行的操作函数
// maxRetries: 最大重试次数
// delay: 每次重试之间的延迟
func retryOperation(operation func() error, maxRetries int, delay time.Duration) error {
    var lastErr error
    
    // 尝试执行操作，最多重试 maxRetries 次
    for i := 0; i < maxRetries; i++ {
        err := operation() // 执行操作
        if err == nil {
            return nil // 成功，返回 nil
        }
        
        lastErr = err
        
        // 使用 errors.Is 检查是否是临时错误（支持错误链检查）
        if !errors.Is(err, ErrTemporary) {
            // 非临时错误，不重试，直接返回
            return fmt.Errorf("非临时错误，停止重试: %w", err)
        }
        
        // 如果不是最后一次尝试，等待后重试
        if i < maxRetries-1 {
            fmt.Printf("重试 %d/%d: %v\n", i+1, maxRetries, err)
            time.Sleep(delay) // 等待指定时间
        }
    }
    
    // 所有重试都失败
    return fmt.Errorf("操作失败，已重试 %d 次: %w", maxRetries, lastErr)
}

func main() {
    err := retryOperation(unreliableOperation, 3, time.Second)
    if err != nil {
        fmt.Printf("最终失败: %v\n", err)
    } else {
        fmt.Println("操作成功")
    }
}
```

### Demo 6: 错误分类和处理

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

// ErrorType 错误类型枚举
type ErrorType int

const (
    ErrorTypeNotFound ErrorType = iota // 资源未找到
    ErrorTypePermission                // 权限不足
    ErrorTypeInvalid                   // 无效操作
    ErrorTypeNetwork                   // 网络错误
)

// AppError 应用错误类型（自定义错误类型，支持错误链）
type AppError struct {
    Type    ErrorType // 错误类型
    Message string    // 错误消息
    Cause   error     // 原始错误（支持错误链）
}

// Error 实现 error 接口
func (e *AppError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Cause)
    }
    return e.Message
}

// Unwrap 实现错误链支持（Go 1.13+）
func (e *AppError) Unwrap() error {
    return e.Cause
}

// handleFileOperation 处理文件操作（演示错误分类）
func handleFileOperation(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        // 根据错误类型分类处理
        if os.IsNotExist(err) {
            // 文件不存在错误
            return &AppError{
                Type:    ErrorTypeNotFound,
                Message: "文件不存在",
                Cause:   err,
            }
        }
        if os.IsPermission(err) {
            // 权限错误
            return &AppError{
                Type:    ErrorTypePermission,
                Message: "权限不足",
                Cause:   err,
            }
        }
        // 其他错误
        return &AppError{
            Type:    ErrorTypeInvalid,
            Message: "文件操作失败",
            Cause:   err,
        }
    }
    defer file.Close()
    
    return nil
}

// handleError 根据错误类型进行不同处理（演示 errors.As 的使用）
func handleError(err error) {
    var appErr *AppError
    // 使用 errors.As 检查错误是否是 AppError 类型（支持错误链检查）
    if errors.As(err, &appErr) {
        // 根据错误类型进行不同处理
        switch appErr.Type {
        case ErrorTypeNotFound:
            fmt.Println("处理: 资源未找到，使用默认配置")
        case ErrorTypePermission:
            fmt.Println("处理: 权限不足，请检查文件权限")
        case ErrorTypeInvalid:
            fmt.Println("处理: 无效操作，跳过")
        case ErrorTypeNetwork:
            fmt.Println("处理: 网络错误，稍后重试")
        default:
            fmt.Printf("处理: 未知错误: %v\n", err)
        }
    } else {
        // 不是 AppError 类型，按其他错误处理
        fmt.Printf("处理: 其他错误: %v\n", err)
    }
}

func main() {
    err := handleFileOperation("nonexistent.txt")
    if err != nil {
        handleError(err)
    }
}
```

## 错误处理最佳实践

1. **错误检查**：
   - 总是检查错误
   - 不要忽略错误（除非有明确理由）

2. **错误信息**：
   - 提供有意义的错误信息
   - 包含上下文信息
   - 使用 `fmt.Errorf` 和 `%w` 包装错误

3. **错误类型**：
   - 使用 `errors.Is` 检查错误值
   - 使用 `errors.As` 检查错误类型
   - 定义错误变量而不是字符串

4. **错误处理位置**：
   - 在调用链的适当位置处理错误
   - 不要过度包装错误
   - 在边界处处理错误（如 main 函数）

5. **避免 panic**：
   - 只在真正不可恢复的情况下使用 panic
   - 使用 `recover` 恢复 panic（谨慎使用）

## 下一步

- [包和模块](./10-包和模块.md) - 学习 Go 的包管理和模块系统

