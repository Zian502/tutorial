# 错误处理

## Error 接口

Go 使用 `error` 接口表示错误。

```go
type error interface {
    Error() string
}
```

### 创建错误

```go
import "errors"

err := errors.New("发生了错误")
fmt.Println(err.Error())  // 发生了错误
```

### 格式化错误

```go
import "fmt"

err := fmt.Errorf("用户 %s 不存在", username)
```

**与其他语言对比**：
- **C++**: 既可以使用返回值/错误码，也广泛使用异常机制 `try/catch`
- **Rust**: `Result<T, E>` 类型，更安全
- **Java**: `Exception` 类，使用 try-catch

**Go 特点**：
- 错误是值，不是异常
- 显式错误处理
- 没有 try-catch

## 错误处理模式

### 基本模式

```go
result, err := doSomething()
if err != nil {
    // 处理错误
    return err
}
// 使用 result
```

### 多返回值

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为0")
    }
    return a / b, nil
}

// 使用
result, err := divide(10, 2)
if err != nil {
    fmt.Printf("错误: %v\n", err)
    return
}
fmt.Printf("结果: %.2f\n", result)
```

### 错误包装

Go 1.13+ 支持错误包装。

```go
import "fmt"

func readFile(filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("读取文件失败: %w", err)  // %w 包装错误
    }
    // ...
    return nil
}
```

### 错误检查

```go
import "errors"

if errors.Is(err, os.ErrNotExist) {
    // 文件不存在
}

var pathErr *os.PathError
if errors.As(err, &pathErr) {
    // 是 PathError 类型
    fmt.Println(pathErr.Path)
}
```

## 自定义错误类型

```go
type MyError struct {
    Code    int
    Message string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("错误代码 %d: %s", e.Code, e.Message)
}

func doSomething() error {
    return &MyError{
        Code:    404,
        Message: "资源未找到",
    }
}
```

## 实际应用场景 Demo

### Demo 1: 文件操作错误处理

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
)

func readFileContent(filename string) (string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return "", fmt.Errorf("打开文件失败: %w", err)
    }
    defer file.Close()
    
    content, err := ioutil.ReadAll(file)
    if err != nil {
        return "", fmt.Errorf("读取文件失败: %w", err)
    }
    
    return string(content), nil
}

func writeFileContent(filename, content string) error {
    file, err := os.Create(filename)
    if err != nil {
        return fmt.Errorf("创建文件失败: %w", err)
    }
    defer file.Close()
    
    _, err = file.WriteString(content)
    if err != nil {
        return fmt.Errorf("写入文件失败: %w", err)
    }
    
    return nil
}

func main() {
    // 读取文件
    content, err := readFileContent("test.txt")
    if err != nil {
        fmt.Printf("读取失败: %v\n", err)
        // 可以继续处理或返回
    } else {
        fmt.Printf("文件内容: %s\n", content)
    }
    
    // 写入文件
    err = writeFileContent("output.txt", "Hello, Go!")
    if err != nil {
        fmt.Printf("写入失败: %v\n", err)
    } else {
        fmt.Println("写入成功")
    }
}
```

### Demo 2: 网络请求错误处理

```go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
)

type HTTPError struct {
    StatusCode int
    URL        string
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.URL)
}

func fetchURL(url string, timeout time.Duration) ([]byte, error) {
    client := &http.Client{
        Timeout: timeout,
    }
    
    resp, err := client.Get(url)
    if err != nil {
        return nil, fmt.Errorf("请求失败: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, &HTTPError{
            StatusCode: resp.StatusCode,
            URL:        url,
        }
    }
    
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("读取响应失败: %w", err)
    }
    
    return body, nil
}

func main() {
    url := "https://api.github.com/users/octocat"
    
    data, err := fetchURL(url, time.Second*5)
    if err != nil {
        if httpErr, ok := err.(*HTTPError); ok {
            fmt.Printf("HTTP 错误: %v\n", httpErr)
        } else {
            fmt.Printf("请求错误: %v\n", err)
        }
        return
    }
    
    fmt.Printf("响应长度: %d 字节\n", len(data))
}
```

### Demo 3: 数据库操作错误处理

```go
package main

import (
    "errors"
    "fmt"
)

var (
    ErrNotFound      = errors.New("记录未找到")
    ErrInvalidInput  = errors.New("无效输入")
    ErrDuplicateKey  = errors.New("重复键")
)

type User struct {
    ID   int
    Name string
}

type UserRepository struct {
    users map[int]*User
}

func NewUserRepository() *UserRepository {
    return &UserRepository{
        users: make(map[int]*User),
    }
}

func (r *UserRepository) Create(user *User) error {
    if user.Name == "" {
        return ErrInvalidInput
    }
    
    if _, exists := r.users[user.ID]; exists {
        return ErrDuplicateKey
    }
    
    r.users[user.ID] = user
    return nil
}

func (r *UserRepository) FindByID(id int) (*User, error) {
    user, exists := r.users[id]
    if !exists {
        return nil, ErrNotFound
    }
    return user, nil
}

func (r *UserRepository) Update(user *User) error {
    if _, exists := r.users[user.ID]; !exists {
        return ErrNotFound
    }
    
    if user.Name == "" {
        return ErrInvalidInput
    }
    
    r.users[user.ID] = user
    return nil
}

func main() {
    repo := NewUserRepository()
    
    // 创建用户
    user := &User{ID: 1, Name: "Alice"}
    if err := repo.Create(user); err != nil {
        if err == ErrDuplicateKey {
            fmt.Println("用户已存在")
        } else {
            fmt.Printf("创建失败: %v\n", err)
        }
    }
    
    // 查找用户
    found, err := repo.FindByID(1)
    if err != nil {
        if err == ErrNotFound {
            fmt.Println("用户不存在")
        } else {
            fmt.Printf("查找失败: %v\n", err)
        }
    } else {
        fmt.Printf("找到用户: %+v\n", found)
    }
    
    // 查找不存在的用户
    _, err = repo.FindByID(999)
    if errors.Is(err, ErrNotFound) {
        fmt.Println("用户 999 不存在")
    }
}
```

### Demo 4: 错误链和上下文

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func readConfig() error {
    filename := "config.json"
    
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("打开配置文件失败: %w", err)
    }
    defer file.Close()
    
    // 模拟读取配置
    data := make([]byte, 100)
    _, err = file.Read(data)
    if err != nil {
        return fmt.Errorf("读取配置内容失败: %w", err)
    }
    
    return nil
}

func validateConfig() error {
    err := readConfig()
    if err != nil {
        return fmt.Errorf("配置验证失败: %w", err)
    }
    return nil
}

func initializeApp() error {
    err := validateConfig()
    if err != nil {
        return fmt.Errorf("应用初始化失败: %w", err)
    }
    return nil
}

func main() {
    err := initializeApp()
    if err != nil {
        fmt.Printf("错误: %v\n", err)
        fmt.Printf("错误链:\n")
        
        // 检查错误链
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("  原因: 文件不存在")
        }
        
        // 展开错误链
        for err != nil {
            fmt.Printf("  - %v\n", err)
            err = errors.Unwrap(err)
        }
    }
}
```

### Demo 5: 重试机制

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

var ErrTemporary = errors.New("临时错误")

func unreliableOperation() error {
    // 模拟随机失败
    if time.Now().Unix()%3 == 0 {
        return ErrTemporary
    }
    return nil
}

func retryOperation(operation func() error, maxRetries int, delay time.Duration) error {
    var lastErr error
    
    for i := 0; i < maxRetries; i++ {
        err := operation()
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        // 检查是否是临时错误
        if !errors.Is(err, ErrTemporary) {
            return fmt.Errorf("非临时错误，停止重试: %w", err)
        }
        
        if i < maxRetries-1 {
            fmt.Printf("重试 %d/%d: %v\n", i+1, maxRetries, err)
            time.Sleep(delay)
        }
    }
    
    return fmt.Errorf("操作失败，已重试 %d 次: %w", maxRetries, lastErr)
}

func main() {
    err := retryOperation(unreliableOperation, 3, time.Second)
    if err != nil {
        fmt.Printf("最终失败: %v\n", err)
    } else {
        fmt.Println("操作成功")
    }
}
```

### Demo 6: 错误分类和处理

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

type ErrorType int

const (
    ErrorTypeNotFound ErrorType = iota
    ErrorTypePermission
    ErrorTypeInvalid
    ErrorTypeNetwork
)

type AppError struct {
    Type    ErrorType
    Message string
    Cause   error
}

func (e *AppError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Cause)
    }
    return e.Message
}

func (e *AppError) Unwrap() error {
    return e.Cause
}

func handleFileOperation(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        if os.IsNotExist(err) {
            return &AppError{
                Type:    ErrorTypeNotFound,
                Message: "文件不存在",
                Cause:   err,
            }
        }
        if os.IsPermission(err) {
            return &AppError{
                Type:    ErrorTypePermission,
                Message: "权限不足",
                Cause:   err,
            }
        }
        return &AppError{
            Type:    ErrorTypeInvalid,
            Message: "文件操作失败",
            Cause:   err,
        }
    }
    defer file.Close()
    
    return nil
}

func handleError(err error) {
    var appErr *AppError
    if errors.As(err, &appErr) {
        switch appErr.Type {
        case ErrorTypeNotFound:
            fmt.Println("处理: 资源未找到，使用默认配置")
        case ErrorTypePermission:
            fmt.Println("处理: 权限不足，请检查文件权限")
        case ErrorTypeInvalid:
            fmt.Println("处理: 无效操作，跳过")
        case ErrorTypeNetwork:
            fmt.Println("处理: 网络错误，稍后重试")
        default:
            fmt.Printf("处理: 未知错误: %v\n", err)
        }
    } else {
        fmt.Printf("处理: 其他错误: %v\n", err)
    }
}

func main() {
    err := handleFileOperation("nonexistent.txt")
    if err != nil {
        handleError(err)
    }
}
```

## 错误处理最佳实践

1. **错误检查**：
   - 总是检查错误
   - 不要忽略错误（除非有明确理由）

2. **错误信息**：
   - 提供有意义的错误信息
   - 包含上下文信息
   - 使用 `fmt.Errorf` 和 `%w` 包装错误

3. **错误类型**：
   - 使用 `errors.Is` 检查错误值
   - 使用 `errors.As` 检查错误类型
   - 定义错误变量而不是字符串

4. **错误处理位置**：
   - 在调用链的适当位置处理错误
   - 不要过度包装错误
   - 在边界处处理错误（如 main 函数）

5. **避免 panic**：
   - 只在真正不可恢复的情况下使用 panic
   - 使用 `recover` 恢复 panic（谨慎使用）

## 下一步

- [包和模块](./10-包和模块.md) - 学习 Go 的包管理和模块系统

