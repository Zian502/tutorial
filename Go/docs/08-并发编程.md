# 并发编程

## Goroutine

Goroutine 是 Go 的轻量级线程，由 Go 运行时管理。

### 基本语法

```go
go function()  // 启动一个新的 goroutine
```

### 示例

```go
func sayHello() {
    fmt.Println("Hello")
}

func main() {
    go sayHello()  // 异步执行
    fmt.Println("World")
    time.Sleep(time.Second)  // 等待 goroutine 完成
}
```

**与其他语言对比**：
- **C++**: 使用 `std::thread` 或各类线程库，线程较为重量级
- **Rust**: `tokio` async/await，类似但不同模型
- **Java**: `Thread` 类，重量级线程

**Go 特点**：
- 轻量级（几 KB 栈空间）
- 启动成本低
- 由 Go 运行时调度

## Channel

Channel 是 goroutine 之间通信的管道。

### 创建 Channel

```go
ch := make(chan int)        // 无缓冲 channel
ch := make(chan int, 10)    // 缓冲 channel（容量10）
```

### 发送和接收

```go
ch <- value    // 发送数据到 channel
value := <-ch  // 从 channel 接收数据
```

### 关闭 Channel

```go
close(ch)

// 检查 channel 是否关闭
value, ok := <-ch
if !ok {
    // channel 已关闭
}
```

**与其他语言对比**：
- **C++**: 没有内置 channel，一般通过队列 + 锁/条件变量实现
- **Rust**: `std::sync::mpsc` channel
- **Java**: `BlockingQueue`，类似但不同

## 无缓冲 Channel

无缓冲 channel 是同步的，发送和接收必须同时准备好。

```go
ch := make(chan int)

go func() {
    ch <- 42  // 发送
}()

value := <-ch  // 接收
fmt.Println(value)  // 42
```

## 缓冲 Channel

缓冲 channel 可以存储多个值，直到缓冲区满。

```go
ch := make(chan int, 3)

ch <- 1
ch <- 2
ch <- 3
// ch <- 4  // 这里会阻塞，因为缓冲区已满

fmt.Println(<-ch)  // 1
fmt.Println(<-ch)  // 2
fmt.Println(<-ch)  // 3
```

## Select 语句

`select` 用于在多个 channel 操作中选择。

```go
select {
case msg1 := <-ch1:
    fmt.Println("收到 ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("收到 ch2:", msg2)
case ch3 <- 3:
    fmt.Println("发送到 ch3")
default:
    fmt.Println("没有 channel 准备好")
}
```

## 实际应用场景 Demo

### Demo 1: 并发下载

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// download 下载函数（在 goroutine 中执行）
// wg: WaitGroup 用于同步，确保所有下载完成
func download(url string, wg *sync.WaitGroup) {
    // defer 确保函数返回时调用 Done，通知 WaitGroup 完成
    defer wg.Done()
    
    // 模拟下载过程
    fmt.Printf("开始下载: %s\n", url)
    time.Sleep(time.Second * 2) // 模拟下载耗时 2 秒
    fmt.Printf("完成下载: %s\n", url)
}

func main() {
    urls := []string{
        "http://example.com/file1",
        "http://example.com/file2",
        "http://example.com/file3",
    }
    
    var wg sync.WaitGroup // 创建 WaitGroup 用于等待所有 goroutine 完成
    
    start := time.Now() // 记录开始时间
    // 为每个 URL 启动一个 goroutine 并发下载
    for _, url := range urls {
        wg.Add(1)              // 增加等待计数
        go download(url, &wg)  // 启动 goroutine 并发执行
    }
    
    wg.Wait() // 等待所有 goroutine 完成
    elapsed := time.Since(start) // 计算总耗时
    
    fmt.Printf("\n总耗时: %v\n", elapsed)
    fmt.Println("如果是串行下载，需要:", time.Second*2*3) // 对比串行耗时
}
```

### Demo 2: 生产者-消费者模式

```go
package main

import (
    "fmt"
    "time"
)

// producer 生产者函数（只发送数据到 channel）
// ch chan<- int 表示只能发送的 channel
func producer(ch chan<- int) {
    // 生产 10 个数据
    for i := 0; i < 10; i++ {
        fmt.Printf("生产: %d\n", i)
        ch <- i                    // 发送数据到 channel
        time.Sleep(time.Millisecond * 100) // 模拟生产耗时
    }
    close(ch) // 关闭 channel，通知消费者没有更多数据
}

// consumer 消费者函数（只从 channel 接收数据）
// ch <-chan int 表示只能接收的 channel
func consumer(ch <-chan int, done chan<- bool) {
    // 使用 range 从 channel 接收数据，直到 channel 关闭
    for value := range ch {
        fmt.Printf("消费: %d\n", value)
        time.Sleep(time.Millisecond * 200) // 模拟消费耗时
    }
    done <- true // 通知主 goroutine 消费完成
}

func main() {
    ch := make(chan int, 5)  // 创建缓冲 channel（容量为 5）
    done := make(chan bool)  // 用于通知完成的 channel
    
    // 启动生产者和消费者 goroutine
    go producer(ch)
    go consumer(ch, done)
    
    <-done // 等待消费者完成
    fmt.Println("完成")
}
```

### Demo 3: 工作池（Worker Pool）

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// Job 任务结构体
type Job struct {
    ID   int    // 任务 ID
    Data string // 任务数据
}

// Result 结果结构体
type Result struct {
    Job    Job    // 对应的任务
    Output string // 处理结果
}

// worker 工作协程（从 jobs channel 获取任务，处理后将结果发送到 results channel）
func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done() // 函数结束时通知 WaitGroup
    
    // 从 jobs channel 接收任务，直到 channel 关闭
    for job := range jobs {
        fmt.Printf("Worker %d 处理 Job %d\n", id, job.ID)
        
        // 模拟处理任务（耗时操作）
        time.Sleep(time.Second)
        
        // 将处理结果发送到 results channel
        results <- Result{
            Job:    job,
            Output: fmt.Sprintf("Job %d 完成", job.ID),
        }
    }
}

func main() {
    numWorkers := 3  // 工作协程数量
    numJobs := 10    // 任务数量
    
    // 创建缓冲 channel
    jobs := make(chan Job, numJobs)       // 任务 channel
    results := make(chan Result, numJobs) // 结果 channel
    
    var wg sync.WaitGroup
    
    // 启动多个 worker goroutine（工作池模式）
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg) // 每个 worker 并发处理任务
    }
    
    // 发送所有任务到 jobs channel
    for j := 1; j <= numJobs; j++ {
        jobs <- Job{ID: j, Data: fmt.Sprintf("data-%d", j)}
    }
    close(jobs) // 关闭 jobs channel，通知 workers 没有更多任务
    
    // 在 goroutine 中等待所有 workers 完成，然后关闭 results channel
    go func() {
        wg.Wait()        // 等待所有 workers 完成
        close(results)   // 关闭 results channel
    }()
    
    // 从 results channel 收集所有结果
    for result := range results {
        fmt.Printf("结果: %s\n", result.Output)
    }
}
```

### Demo 4: 超时控制

```go
package main

import (
    "fmt"
    "time"
)

// longRunningTask 模拟长时间运行的任务
func longRunningTask() string {
    time.Sleep(time.Second * 3) // 模拟耗时 3 秒
    return "任务完成"
}

// withTimeout 带超时控制的函数执行
// 如果任务在指定时间内完成，返回结果；否则返回超时错误
func withTimeout(fn func() string, timeout time.Duration) (string, error) {
    resultChan := make(chan string, 1) // 结果 channel
    errorChan := make(chan error, 1)   // 错误 channel（未使用，可删除）
    
    // 在 goroutine 中执行任务
    go func() {
        resultChan <- fn() // 将任务结果发送到 channel
    }()
    
    // select 语句：等待结果或超时
    select {
    case result := <-resultChan:
        // 任务在超时前完成
        return result, nil
    case <-time.After(timeout):
        // 超时：time.After 返回一个 channel，在指定时间后发送值
        return "", fmt.Errorf("操作超时")
    }
}

func main() {
    // 正常情况
    result, err := withTimeout(longRunningTask, time.Second*5)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("结果: %s\n", result)
    }
    
    // 超时情况
    result, err = withTimeout(longRunningTask, time.Second*2)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("结果: %s\n", result)
    }
}
```

### Demo 5: 扇入扇出模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// fanIn 扇入模式：将多个 channel 合并为一个 channel
// 从多个输入 channel 接收数据，合并到一个输出 channel
func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int) // 输出 channel
    
    // 从单个 channel 读取数据并发送到输出 channel
    output := func(c <-chan int) {
        defer wg.Done()
        // 从输入 channel 读取所有数据
        for n := range c {
            out <- n // 发送到输出 channel
        }
    }
    
    // 为每个输入 channel 启动一个 goroutine
    wg.Add(len(channels))
    for _, c := range channels {
        go output(c) // 并发读取各个 channel
    }
    
    // 等待所有 goroutine 完成，然后关闭输出 channel
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

// fanOut 扇出模式：将一个 channel 分发到多个 channel
// 将输入 channel 的数据分发到多个输出 channel，每个输出 channel 由独立的 worker 处理
func fanOut(in <-chan int, numWorkers int) []<-chan int {
    outputs := make([]<-chan int, numWorkers) // 创建多个输出 channel
    
    for i := 0; i < numWorkers; i++ {
        out := make(chan int)
        outputs[i] = out
        
        // 为每个输出 channel 启动一个 worker goroutine
        go func(out chan<- int) {
            defer close(out) // worker 结束时关闭 channel
            // 从输入 channel 读取数据并处理
            for value := range in {
                out <- value * 2 // 处理数据（示例：乘以 2）
            }
        }(out)
    }
    
    return outputs
}

func main() {
    // 创建输入 channel
    in := make(chan int)
    
    // 扇出到 3 个 workers
    outputs := fanOut(in, 3)
    
    // 扇入合并结果
    merged := fanIn(outputs...)
    
    // 发送数据
    go func() {
        for i := 1; i <= 10; i++ {
            in <- i
        }
        close(in)
    }()
    
    // 接收结果
    for result := range merged {
        fmt.Printf("结果: %d\n", result)
    }
}
```

### Demo 6: 并发安全的计数器

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// SafeCounter 并发安全的计数器
type SafeCounter struct {
    mu    sync.Mutex // 互斥锁，保护共享数据
    value int        // 计数值
}

// Increment 增加计数器（使用互斥锁保护）
func (c *SafeCounter) Increment() {
    c.mu.Lock()         // 获取锁
    defer c.mu.Unlock() // 确保函数返回时释放锁
    c.value++           // 增加计数（临界区操作）
}

// GetValue 获取计数器值（使用互斥锁保护）
func (c *SafeCounter) GetValue() int {
    c.mu.Lock()         // 获取锁
    defer c.mu.Unlock() // 确保函数返回时释放锁
    return c.value      // 返回计数值（临界区操作）
}

func main() {
    counter := SafeCounter{}
    var wg sync.WaitGroup
    
    // 启动 100 个 goroutine 并发增加计数器
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    fmt.Printf("最终值: %d (期望: 100000)\n", counter.GetValue())
}
```

### Demo 7: 使用 Channel 实现信号量

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// Semaphore 信号量（使用 channel 实现）
// 用于控制并发数量，限制同时执行的 goroutine 数量
type Semaphore struct {
    ch chan struct{} // 使用 channel 作为信号量
}

// NewSemaphore 创建信号量，n 表示允许的最大并发数
func NewSemaphore(n int) *Semaphore {
    return &Semaphore{
        // 创建容量为 n 的缓冲 channel
        // channel 中的元素数量表示当前可用的资源数
        ch: make(chan struct{}, n),
    }
}

// Acquire 获取信号量（获取资源）
// 如果 channel 已满（达到最大并发数），会阻塞等待
func (s *Semaphore) Acquire() {
    s.ch <- struct{}{} // 向 channel 发送值（占用一个资源）
}

// Release 释放信号量（释放资源）
func (s *Semaphore) Release() {
    <-s.ch // 从 channel 接收值（释放一个资源）
}

// worker 工作协程（使用信号量控制并发）
func worker(id int, sem *Semaphore, wg *sync.WaitGroup) {
    defer wg.Done()
    
    sem.Acquire()         // 获取信号量（如果达到最大并发数会阻塞）
    defer sem.Release()   // 确保工作完成后释放信号量
    
    fmt.Printf("Worker %d 开始工作\n", id)
    time.Sleep(time.Second) // 模拟工作
    fmt.Printf("Worker %d 完成工作\n", id)
}

func main() {
    sem := NewSemaphore(3)  // 最多 3 个并发
    var wg sync.WaitGroup
    
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go worker(i, sem, &wg)
    }
    
    wg.Wait()
    fmt.Println("所有工作完成")
}
```

## Sync 包

### WaitGroup

等待一组 goroutine 完成。

```go
var wg sync.WaitGroup

wg.Add(1)
go func() {
    defer wg.Done()
    // 工作
}()

wg.Wait()  // 等待完成
```

### Mutex

互斥锁，保护共享资源。

```go
var mu sync.Mutex
var counter int

mu.Lock()
counter++
mu.Unlock()
```

### RWMutex

读写锁，允许多个读或一个写。

```go
var rwmu sync.RWMutex

// 读锁
rwmu.RLock()
// 读取操作
rwmu.RUnlock()

// 写锁
rwmu.Lock()
// 写入操作
rwmu.Unlock()
```

### Once

确保函数只执行一次。

```go
var once sync.Once

once.Do(func() {
    // 只执行一次
})
```

## 并发编程最佳实践

1. **Goroutine 管理**：
   - 使用 `sync.WaitGroup` 等待 goroutine 完成
   - 避免 goroutine 泄漏

2. **Channel 使用**：
   - 发送方关闭 channel
   - 使用 `range` 接收直到 channel 关闭
   - 避免在接收方关闭 channel

3. **数据竞争**：
   - 使用 channel 或 mutex 保护共享数据
   - 使用 `go run -race` 检测数据竞争

4. **性能考虑**：
   - 避免过度使用 goroutine
   - 使用缓冲 channel 提高性能
   - 考虑使用 worker pool 模式

## 下一步

- [错误处理](./09-错误处理.md) - 学习 Go 的错误处理机制

