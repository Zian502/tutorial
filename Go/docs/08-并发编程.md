# 并发编程

## Goroutine

Goroutine 是 Go 的轻量级线程，由 Go 运行时管理。

### 基本语法

```go
go function()  // 启动一个新的 goroutine
```

### 示例

```go
func sayHello() {
    fmt.Println("Hello")
}

func main() {
    go sayHello()  // 异步执行
    fmt.Println("World")
    time.Sleep(time.Second)  // 等待 goroutine 完成
}
```

**与其他语言对比**：
- **C++**: 使用 `std::thread` 或各类线程库，线程较为重量级
- **Rust**: `tokio` async/await，类似但不同模型
- **Java**: `Thread` 类，重量级线程

**Go 特点**：
- 轻量级（几 KB 栈空间）
- 启动成本低
- 由 Go 运行时调度

## Channel

Channel 是 goroutine 之间通信的管道。

### 创建 Channel

```go
ch := make(chan int)        // 无缓冲 channel
ch := make(chan int, 10)    // 缓冲 channel（容量10）
```

### 发送和接收

```go
ch <- value    // 发送数据到 channel
value := <-ch  // 从 channel 接收数据
```

### 关闭 Channel

```go
close(ch)

// 检查 channel 是否关闭
value, ok := <-ch
if !ok {
    // channel 已关闭
}
```

**与其他语言对比**：
- **C++**: 没有内置 channel，一般通过队列 + 锁/条件变量实现
- **Rust**: `std::sync::mpsc` channel
- **Java**: `BlockingQueue`，类似但不同

## 无缓冲 Channel

无缓冲 channel 是同步的，发送和接收必须同时准备好。

```go
ch := make(chan int)

go func() {
    ch <- 42  // 发送
}()

value := <-ch  // 接收
fmt.Println(value)  // 42
```

## 缓冲 Channel

缓冲 channel 可以存储多个值，直到缓冲区满。

```go
ch := make(chan int, 3)

ch <- 1
ch <- 2
ch <- 3
// ch <- 4  // 这里会阻塞，因为缓冲区已满

fmt.Println(<-ch)  // 1
fmt.Println(<-ch)  // 2
fmt.Println(<-ch)  // 3
```

## Select 语句

`select` 用于在多个 channel 操作中选择。

```go
select {
case msg1 := <-ch1:
    fmt.Println("收到 ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("收到 ch2:", msg2)
case ch3 <- 3:
    fmt.Println("发送到 ch3")
default:
    fmt.Println("没有 channel 准备好")
}
```

## 实际应用场景 Demo

### Demo 1: 并发下载

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func download(url string, wg *sync.WaitGroup) {
    defer wg.Done()
    
    // 模拟下载
    fmt.Printf("开始下载: %s\n", url)
    time.Sleep(time.Second * 2)
    fmt.Printf("完成下载: %s\n", url)
}

func main() {
    urls := []string{
        "http://example.com/file1",
        "http://example.com/file2",
        "http://example.com/file3",
    }
    
    var wg sync.WaitGroup
    
    start := time.Now()
    for _, url := range urls {
        wg.Add(1)
        go download(url, &wg)
    }
    
    wg.Wait()
    elapsed := time.Since(start)
    
    fmt.Printf("\n总耗时: %v\n", elapsed)
    fmt.Println("如果是串行下载，需要:", time.Second*2*3)
}
```

### Demo 2: 生产者-消费者模式

```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan<- int) {
    for i := 0; i < 10; i++ {
        fmt.Printf("生产: %d\n", i)
        ch <- i
        time.Sleep(time.Millisecond * 100)
    }
    close(ch)
}

func consumer(ch <-chan int, done chan<- bool) {
    for value := range ch {
        fmt.Printf("消费: %d\n", value)
        time.Sleep(time.Millisecond * 200)
    }
    done <- true
}

func main() {
    ch := make(chan int, 5)  // 缓冲 channel
    done := make(chan bool)
    
    go producer(ch)
    go consumer(ch, done)
    
    <-done
    fmt.Println("完成")
}
```

### Demo 3: 工作池（Worker Pool）

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Job struct {
    ID     int
    Data   string
}

type Result struct {
    Job    Job
    Output string
}

func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        fmt.Printf("Worker %d 处理 Job %d\n", id, job.ID)
        
        // 模拟处理
        time.Sleep(time.Second)
        
        results <- Result{
            Job:    job,
            Output: fmt.Sprintf("Job %d 完成", job.ID),
        }
    }
}

func main() {
    numWorkers := 3
    numJobs := 10
    
    jobs := make(chan Job, numJobs)
    results := make(chan Result, numJobs)
    
    var wg sync.WaitGroup
    
    // 启动 workers
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }
    
    // 发送 jobs
    for j := 1; j <= numJobs; j++ {
        jobs <- Job{ID: j, Data: fmt.Sprintf("data-%d", j)}
    }
    close(jobs)
    
    // 等待 workers 完成
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // 收集结果
    for result := range results {
        fmt.Printf("结果: %s\n", result.Output)
    }
}
```

### Demo 4: 超时控制

```go
package main

import (
    "fmt"
    "time"
)

func longRunningTask() string {
    time.Sleep(time.Second * 3)
    return "任务完成"
}

func withTimeout(fn func() string, timeout time.Duration) (string, error) {
    resultChan := make(chan string, 1)
    errorChan := make(chan error, 1)
    
    go func() {
        resultChan <- fn()
    }()
    
    select {
    case result := <-resultChan:
        return result, nil
    case <-time.After(timeout):
        return "", fmt.Errorf("操作超时")
    }
}

func main() {
    // 正常情况
    result, err := withTimeout(longRunningTask, time.Second*5)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("结果: %s\n", result)
    }
    
    // 超时情况
    result, err = withTimeout(longRunningTask, time.Second*2)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("结果: %s\n", result)
    }
}
```

### Demo 5: 扇入扇出模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 扇入：合并多个 channel
func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)
    
    output := func(c <-chan int) {
        defer wg.Done()
        for n := range c {
            out <- n
        }
    }
    
    wg.Add(len(channels))
    for _, c := range channels {
        go output(c)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

// 扇出：分发到多个 channel
func fanOut(in <-chan int, numWorkers int) []<-chan int {
    outputs := make([]<-chan int, numWorkers)
    
    for i := 0; i < numWorkers; i++ {
        out := make(chan int)
        outputs[i] = out
        
        go func(out chan<- int) {
            defer close(out)
            for value := range in {
                out <- value * 2  // 处理数据
            }
        }(out)
    }
    
    return outputs
}

func main() {
    // 创建输入 channel
    in := make(chan int)
    
    // 扇出到 3 个 workers
    outputs := fanOut(in, 3)
    
    // 扇入合并结果
    merged := fanIn(outputs...)
    
    // 发送数据
    go func() {
        for i := 1; i <= 10; i++ {
            in <- i
        }
        close(in)
    }()
    
    // 接收结果
    for result := range merged {
        fmt.Printf("结果: %d\n", result)
    }
}
```

### Demo 6: 并发安全的计数器

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *SafeCounter) GetValue() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func main() {
    counter := SafeCounter{}
    var wg sync.WaitGroup
    
    // 启动 100 个 goroutine 并发增加计数器
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    fmt.Printf("最终值: %d (期望: 100000)\n", counter.GetValue())
}
```

### Demo 7: 使用 Channel 实现信号量

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Semaphore struct {
    ch chan struct{}
}

func NewSemaphore(n int) *Semaphore {
    return &Semaphore{
        ch: make(chan struct{}, n),
    }
}

func (s *Semaphore) Acquire() {
    s.ch <- struct{}{}
}

func (s *Semaphore) Release() {
    <-s.ch
}

func worker(id int, sem *Semaphore, wg *sync.WaitGroup) {
    defer wg.Done()
    
    sem.Acquire()
    defer sem.Release()
    
    fmt.Printf("Worker %d 开始工作\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d 完成工作\n", id)
}

func main() {
    sem := NewSemaphore(3)  // 最多 3 个并发
    var wg sync.WaitGroup
    
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go worker(i, sem, &wg)
    }
    
    wg.Wait()
    fmt.Println("所有工作完成")
}
```

## Sync 包

### WaitGroup

等待一组 goroutine 完成。

```go
var wg sync.WaitGroup

wg.Add(1)
go func() {
    defer wg.Done()
    // 工作
}()

wg.Wait()  // 等待完成
```

### Mutex

互斥锁，保护共享资源。

```go
var mu sync.Mutex
var counter int

mu.Lock()
counter++
mu.Unlock()
```

### RWMutex

读写锁，允许多个读或一个写。

```go
var rwmu sync.RWMutex

// 读锁
rwmu.RLock()
// 读取操作
rwmu.RUnlock()

// 写锁
rwmu.Lock()
// 写入操作
rwmu.Unlock()
```

### Once

确保函数只执行一次。

```go
var once sync.Once

once.Do(func() {
    // 只执行一次
})
```

## 并发编程最佳实践

1. **Goroutine 管理**：
   - 使用 `sync.WaitGroup` 等待 goroutine 完成
   - 避免 goroutine 泄漏

2. **Channel 使用**：
   - 发送方关闭 channel
   - 使用 `range` 接收直到 channel 关闭
   - 避免在接收方关闭 channel

3. **数据竞争**：
   - 使用 channel 或 mutex 保护共享数据
   - 使用 `go run -race` 检测数据竞争

4. **性能考虑**：
   - 避免过度使用 goroutine
   - 使用缓冲 channel 提高性能
   - 考虑使用 worker pool 模式

## 下一步

- [错误处理](./09-错误处理.md) - 学习 Go 的错误处理机制

