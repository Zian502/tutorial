# 包和模块

## 包（Package）

### 包声明

每个 Go 文件必须以 `package` 声明开始。

```go
package main      // 可执行程序
package utils     // 库包
```

### 包命名规则

- 小写字母
- 简短有意义
- 不使用下划线或混合大小写

### 导入包

```go
import "fmt"
import "os"

// 或
import (
    "fmt"
    "os"
    "strings"
)
```

### 导入别名

```go
import (
    f "fmt"
    _ "database/sql/driver"  // 匿名导入
    m "math"
)
```

## 导出和可见性

- **大写字母开头**：导出（public），其他包可访问
- **小写字母开头**：未导出（private），包内可见

```go
package utils

var PublicVar = "公开变量"    // 导出
var privateVar = "私有变量"   // 未导出

func PublicFunc() { }        // 导出
func privateFunc() { }       // 未导出
```

## Go Modules

Go 1.11+ 引入的模块系统，替代了旧的 GOPATH 模式。

### 初始化模块

```bash
go mod init github.com/username/project
```

这会创建 `go.mod` 文件：

```go
module github.com/username/project

go 1.21
```

### 添加依赖

```bash
go get github.com/gin-gonic/gin
go get github.com/gorilla/mux@v1.8.0  # 指定版本
```

### 更新依赖

```bash
go get -u github.com/gin-gonic/gin     # 更新到最新版本
go get -u ./...                        # 更新所有依赖
```

### 整理依赖

```bash
go mod tidy  # 添加缺失的依赖，移除未使用的依赖
```

### 查看依赖

```bash
go list -m all              # 所有依赖
go list -m -versions github.com/gin-gonic/gin  # 可用版本
```

## 实际应用场景 Demo

### Demo 1: 创建自定义包

创建项目结构：

```
myproject/
├── go.mod
├── main.go
└── utils/
    └── math.go
```

**utils/math.go**:

```go
package utils

// Add 返回两个数的和
// 函数名首字母大写，表示导出（其他包可以访问）
func Add(a, b int) int {
    return a + b
}

// Multiply 返回两个数的积
// 导出函数，可以被其他包调用
func Multiply(a, b int) int {
    return a * b
}

// subtract 是私有函数
// 函数名首字母小写，表示未导出（只能在包内使用）
func subtract(a, b int) int {
    return a - b
}
```

**main.go**:

```go
package main

import (
    "fmt"
    "myproject/utils"  // 导入本地包（模块路径 + 包路径）
)

func main() {
    // 调用导出函数（首字母大写）
    sum := utils.Add(10, 5)
    product := utils.Multiply(10, 5)
    
    fmt.Printf("和: %d\n", sum)
    fmt.Printf("积: %d\n", product)
    
    // utils.subtract(10, 5)  // 错误：subtract 未导出（首字母小写），无法访问
}
```

### Demo 2: 使用第三方包

**go.mod**:

```go
module myproject

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
)
```

**main.go**:

```go
package main

import (
    "net/http"
    "github.com/gin-gonic/gin"  // 导入第三方包（从 go.mod 的 require 中获取）
)

func main() {
    // 创建 Gin 路由引擎（使用第三方库）
    r := gin.Default()
    
    // 注册路由处理函数
    r.GET("/ping", func(c *gin.Context) {
        // 返回 JSON 响应
        c.JSON(http.StatusOK, gin.H{
            "message": "pong",
        })
    })
    
    // 启动 HTTP 服务器，监听 8080 端口
    r.Run(":8080")
}
```

### Demo 3: 包初始化（init 函数）

**config/config.go**:

```go
package config

import "fmt"

// 包级别变量
var AppName string
var Version string

// init 函数：包初始化函数
// 在包被导入时自动执行，在 main 函数之前执行
// 可以有多个 init 函数，按顺序执行
func init() {
    AppName = "MyApp"
    Version = "1.0.0"
    fmt.Println("配置包初始化")
}

// GetInfo 获取应用信息
func GetInfo() string {
    return fmt.Sprintf("%s v%s", AppName, Version)
}
```

**main.go**:

```go
package main

import (
    "fmt"
    "myproject/config"  // 导入 config 包，会触发 config 包的 init 函数
)

// main 包的 init 函数
// 执行顺序：config.init() -> main.init() -> main()
func init() {
    fmt.Println("main 包初始化")
}

func main() {
    // 使用 config 包导出的函数
    fmt.Println(config.GetInfo())
}
```

**输出**：
```
配置包初始化
main 包初始化
MyApp v1.0.0
```

### Demo 4: 内部包（internal）

Go 支持 `internal` 目录，其中的包只能被父目录的包导入。

**项目结构**：

```
myproject/
├── go.mod
├── main.go
├── api/
│   └── handler.go
└── internal/
    └── auth/
        └── token.go
```

**internal/auth/token.go**:

```go
package auth

// GenerateToken 生成令牌
// 注意：此包在 internal 目录下，只能被父目录的包导入
func GenerateToken() string {
    return "secret-token"
}
```

**api/handler.go**:

```go
package api

// api 包在 myproject 目录下，可以导入 internal 包
// internal 包的可见性规则：只能被包含 internal 目录的父目录的包导入
import "myproject/internal/auth"  // 可以导入（api 和 internal 在同一父目录下）

func HandleRequest() {
    token := auth.GenerateToken()
    // ...
}
```

**其他项目**：

```go
// 错误：不能导入 internal 包
// 其他项目（不在 myproject 目录下）无法导入 internal 包
import "myproject/internal/auth"  // 编译错误（违反 internal 包规则）
```

### Demo 5: 版本管理

**go.mod**:

```go
module github.com/user/myproject  // 模块路径（用于导入）

go 1.21  // Go 版本要求

// require 块：直接依赖（项目代码中直接使用的包）
require (
    github.com/gin-gonic/gin v1.9.1        // 精确版本
    github.com/go-sql-driver/mysql v1.7.1  // 精确版本
)

// require 块：间接依赖（依赖的依赖，由 Go 自动管理）
require (
    github.com/bytedance/sonic v1.8.0 // indirect 表示间接依赖
    github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect 伪版本
    // ... 更多间接依赖
)
```

**版本选择规则**：

- `v1.9.1`：精确版本（使用指定的确切版本）
- `v1.9`：最新 v1.9.x（使用 v1.9 系列的最新版本）
- `latest`：最新版本（使用该包的最新版本）
- `v0.0.0-20221115062448-fe3a3abad311`：伪版本（commit hash，用于未发布版本或特定 commit）

### Demo 6: 替换依赖（replace）

**go.mod**:

```go
module myproject

go 1.21

require github.com/example/package v1.0.0

// replace 指令：替换依赖源
// 将 github.com/example/package 替换为本地路径
replace github.com/example/package => ../local-package

// 或替换为 fork 的版本
replace github.com/example/package => github.com/fork/package v1.0.0
```

**replace 的使用场景**：
- 本地开发时使用本地版本（修改依赖包进行测试）
- 使用 fork 的版本（使用修改过的第三方包）
- 测试时替换依赖（临时替换依赖进行测试）

### Demo 7: 工作区（Workspace）

Go 1.18+ 支持工作区，可以同时处理多个模块。

**go.work**:

```go
go 1.21

// use 指令：指定工作区中包含的模块
use (
    ./module1    // 相对路径：当前目录下的 module1
    ./module2    // 相对路径：当前目录下的 module2
    ../shared    // 相对路径：上级目录的 shared
)
```

**使用**：

```bash
# 初始化工作区，添加模块
go work init ./module1 ./module2

# 向工作区添加更多模块
go work use ../shared
```

### Demo 8: 构建标签（Build Tags）

使用构建标签控制编译：

**app_debug.go**:

```go
//go:build debug
// 构建标签：只有在编译时指定 debug 标签时才包含此文件
// 语法：//go:build <条件>

package main

func init() {
    debugMode = true  // 调试模式开启
}
```

**app_release.go**:

```go
//go:build !debug
// 构建标签：只有在编译时没有指定 debug 标签时才包含此文件
// !debug 表示"非 debug"

package main

func init() {
    debugMode = false  // 调试模式关闭
}
```

**编译**：

```bash
# 使用 debug 标签编译（会包含 app_debug.go，不包含 app_release.go）
go build -tags debug

# 不使用标签编译（会包含 app_release.go，不包含 app_debug.go）
go build
```

### Demo 9: 条件编译示例

**config_windows.go**:

```go
//go:build windows
// 构建标签：只在 Windows 平台编译时包含此文件
// windows 是 Go 内置的平台标签

package config

// GetConfigPath 获取 Windows 平台的配置路径
func GetConfigPath() string {
    return "C:\\ProgramData\\MyApp\\config.json"  // Windows 路径格式
}
```

**config_unix.go**:

```go
//go:build !windows
// 构建标签：在非 Windows 平台（Linux、macOS 等）编译时包含此文件
// !windows 表示"非 Windows"

package config

// GetConfigPath 获取 Unix 类平台的配置路径
func GetConfigPath() string {
    return "/etc/myapp/config.json"  // Unix 路径格式
}
```

## 包管理最佳实践

1. **模块命名**：
   - 使用完整的导入路径（如 `github.com/user/repo`）
   - 保持向后兼容

2. **版本管理**：
   - 使用语义化版本（SemVer）
   - 主版本更新时更改模块路径（v2+）

3. **依赖管理**：
   - 定期更新依赖：`go get -u ./...`
   - 使用 `go mod tidy` 保持干净
   - 检查依赖：`go list -m all`

4. **包设计**：
   - 保持包小而专注
   - 清晰的导出 API
   - 良好的文档注释

5. **测试**：
   - 测试文件：`*_test.go`
   - 包内测试：`package utils`
   - 外部测试：`package utils_test`

## 常用标准库

### fmt
格式化输入输出

```go
import "fmt"
fmt.Printf("Hello %s\n", "World")
```

### os
操作系统接口

```go
import "os"
os.Getenv("PATH")
os.Exit(1)
```

### net/http
HTTP 客户端和服务器

```go
import "net/http"
http.Get("https://example.com")
```

### encoding/json
JSON 编码解码

```go
import "encoding/json"
json.Marshal(data)
json.Unmarshal(data, &result)
```

### strings
字符串操作

```go
import "strings"
strings.Contains("hello", "ll")
strings.Split("a,b,c", ",")
```

### time
时间操作

```go
import "time"
time.Now()
time.Sleep(time.Second)
```

## 下一步

完成包和模块学习后，你已经掌握了 Go 语言的核心知识！

建议：
1. 阅读 Go 标准库文档
2. 学习常用第三方库（Gin、GORM 等）
3. 完成实际项目练习
4. 学习 Go 最佳实践和设计模式

