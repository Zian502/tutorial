# 接口

## 接口定义

### 基本语法

```go
type InterfaceName interface {
    Method1(param1 type1) returnType1
    Method2(param2 type2) returnType2
}
```

### 示例

```go
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}
```

**与其他语言对比**：
- **C++**: 没有专门的 `interface` 关键字，通常通过纯虚类（只含纯虚函数的 `class`）实现接口语义
- **Rust**: `trait`，类似但更强大
- **Java**: `interface`，类似但需要显式实现

**Go 特点**：
- 隐式实现（不需要 `implements` 关键字）
- 接口是类型
- 可以组合接口

## 接口实现

### 隐式实现

只要类型实现了接口的所有方法，就自动实现了该接口。

```go
type Shape interface {
    Area() float64
}

type Circle struct {
    Radius float64
}

// Circle 实现了 Shape 接口（隐式）
func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

type Rectangle struct {
    Width  float64
    Height float64
}

// Rectangle 也实现了 Shape 接口
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}
```

### 接口作为参数

```go
func printArea(s Shape) {
    fmt.Printf("面积: %.2f\n", s.Area())
}

// 使用
circle := Circle{Radius: 5}
rectangle := Rectangle{Width: 10, Height: 5}

printArea(circle)    // 面积: 78.50
printArea(rectangle) // 面积: 50.00
```

## 空接口

`interface{}` 可以表示任何类型。

```go
func printValue(v interface{}) {
    fmt.Printf("值: %v, 类型: %T\n", v, v)
}

printValue(42)        // int
printValue("hello")   // string
printValue(3.14)      // float64
```

Go 1.18+ 引入了 `any` 作为 `interface{}` 的别名：

```go
func printValue(v any) {  // 等同于 interface{}
    fmt.Printf("值: %v\n", v)
}
```

## 类型断言

### 基本语法

```go
var i interface{} = "hello"

s := i.(string)        // 类型断言
fmt.Println(s)         // hello

s, ok := i.(string)    // 安全类型断言
if ok {
    fmt.Println(s)
}
```

### 类型开关（Type Switch）

```go
func doSomething(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s\n", v)
    case bool:
        fmt.Printf("布尔值: %v\n", v)
    default:
        fmt.Printf("未知类型: %T\n", v)
    }
}
```

## 接口组合

接口可以组合，形成更大的接口。

```go
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type Closer interface {
    Close() error
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

## 实际应用场景 Demo

### Demo 1: 多态图形系统

```go
package main

import (
    "fmt"
    "math"
)

// Shape 形状接口：定义所有形状必须实现的方法
type Shape interface {
    Area() float64      // 计算面积
    Perimeter() float64 // 计算周长
    Name() string       // 返回形状名称
}

// Circle 圆形结构体（实现 Shape 接口）
type Circle struct {
    Radius float64 // 半径
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius // π * r²
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius // 2 * π * r
}

func (c Circle) Name() string {
    return "圆形"
}

// Rectangle 矩形结构体（实现 Shape 接口）
type Rectangle struct {
    Width  float64 // 宽度
    Height float64 // 高度
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height // 宽 * 高
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height) // 2 * (宽 + 高)
}

func (r Rectangle) Name() string {
    return "矩形"
}

// printShapeInfo 打印形状信息（多态：接受接口类型）
func printShapeInfo(s Shape) {
    fmt.Printf("%s:\n", s.Name())
    fmt.Printf("  面积: %.2f\n", s.Area())
    fmt.Printf("  周长: %.2f\n", s.Perimeter())
    fmt.Println()
}

// calculateTotalArea 计算所有形状的总面积（多态应用）
func calculateTotalArea(shapes []Shape) float64 {
    total := 0.0
    // 遍历所有形状，调用接口方法
    for _, s := range shapes {
        total += s.Area() // 多态：不同形状调用各自的 Area 实现
    }
    return total
}

func main() {
    shapes := []Shape{
        Circle{Radius: 5},
        Rectangle{Width: 10, Height: 5},
        Circle{Radius: 3},
        Rectangle{Width: 4, Height: 4},
    }
    
    for _, shape := range shapes {
        printShapeInfo(shape)
    }
    
    fmt.Printf("总面积: %.2f\n", calculateTotalArea(shapes))
}
```

### Demo 2: 数据存储接口

```go
package main

import (
    "fmt"
    "os"
)

// Storage 存储接口：定义存储操作的抽象
type Storage interface {
    Save(key string, value []byte) error   // 保存数据
    Load(key string) ([]byte, error)       // 加载数据
    Delete(key string) error               // 删除数据
}

// MemoryStorage 内存存储实现（实现 Storage 接口）
type MemoryStorage struct {
    data map[string][]byte // 使用 map 存储数据
}

func NewMemoryStorage() *MemoryStorage {
    return &MemoryStorage{
        data: make(map[string][]byte), // 初始化 map
    }
}

// Save 保存数据到内存
func (m *MemoryStorage) Save(key string, value []byte) error {
    m.data[key] = value // 直接存入 map
    return nil
}

// Load 从内存加载数据
func (m *MemoryStorage) Load(key string) ([]byte, error) {
    value, ok := m.data[key]
    if !ok {
        return nil, fmt.Errorf("key not found: %s", key) // key 不存在
    }
    return value, nil
}

// Delete 从内存删除数据
func (m *MemoryStorage) Delete(key string) error {
    delete(m.data, key) // 从 map 中删除
    return nil
}

// FileStorage 文件存储实现（实现 Storage 接口）
type FileStorage struct {
    baseDir string // 存储目录
}

func NewFileStorage(baseDir string) *FileStorage {
    os.MkdirAll(baseDir, 0755) // 创建目录（如果不存在）
    return &FileStorage{baseDir: baseDir}
}

// Save 保存数据到文件
func (f *FileStorage) Save(key string, value []byte) error {
    filename := fmt.Sprintf("%s/%s", f.baseDir, key) // 构建文件路径
    return os.WriteFile(filename, value, 0644)       // 写入文件
}

// Load 从文件加载数据
func (f *FileStorage) Load(key string) ([]byte, error) {
    filename := fmt.Sprintf("%s/%s", f.baseDir, key) // 构建文件路径
    return os.ReadFile(filename)                      // 读取文件
}

// Delete 删除文件
func (f *FileStorage) Delete(key string) error {
    filename := fmt.Sprintf("%s/%s", f.baseDir, key) // 构建文件路径
    return os.Remove(filename)                        // 删除文件
}

// useStorage 使用存储接口（多态：可以接受任何 Storage 实现）
func useStorage(s Storage) {
    // 调用接口方法，实际执行的是具体实现的代码
    s.Save("key1", []byte("value1"))
    s.Save("key2", []byte("value2"))
    
    value, _ := s.Load("key1")
    fmt.Printf("加载 key1: %s\n", value)
    
    s.Delete("key2")
}

func main() {
    fmt.Println("使用内存存储:")
    memoryStorage := NewMemoryStorage()
    useStorage(memoryStorage)
    
    fmt.Println("\n使用文件存储:")
    fileStorage := NewFileStorage("./storage")
    useStorage(fileStorage)
}
```

### Demo 3: 排序接口

```go
package main

import (
    "fmt"
    "sort"
)

// Person 人员结构体
type Person struct {
    Name string // 姓名
    Age  int    // 年龄
}

// ByAge 按年龄排序的类型（实现 sort.Interface）
type ByAge []Person

// Len 返回切片长度（sort.Interface 要求）
func (a ByAge) Len() int { return len(a) }

// Swap 交换两个元素（sort.Interface 要求）
func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

// Less 比较两个元素（sort.Interface 要求）
// 返回 true 表示 i 应该在 j 前面（按年龄升序）
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

// ByName 按姓名排序的类型（实现 sort.Interface）
type ByName []Person

// Len 返回切片长度
func (a ByName) Len() int { return len(a) }

// Swap 交换两个元素
func (a ByName) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

// Less 比较两个元素（按姓名字典序升序）
func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name }

func main() {
    people := []Person{
        {"Bob", 31},
        {"John", 42},
        {"Michael", 17},
        {"Jenny", 26},
    }
    
    fmt.Println("原始顺序:")
    for _, p := range people {
        fmt.Printf("%s (%d)\n", p.Name, p.Age)
    }
    
    fmt.Println("\n按年龄排序:")
    sort.Sort(ByAge(people))
    for _, p := range people {
        fmt.Printf("%s (%d)\n", p.Name, p.Age)
    }
    
    fmt.Println("\n按姓名排序:")
    sort.Sort(ByName(people))
    for _, p := range people {
        fmt.Printf("%s (%d)\n", p.Name, p.Age)
    }
}
```

### Demo 4: HTTP 处理器接口

```go
package main

import (
    "fmt"
    "net/http"
)

// Handler HTTP 处理器接口（标准库 net/http 的接口）
type Handler interface {
    ServeHTTP(http.ResponseWriter, *http.Request) // 处理 HTTP 请求
}

// HelloHandler 问候处理器（实现 Handler 接口）
type HelloHandler struct {
    Name string // 问候的名字
}

// ServeHTTP 处理 HTTP 请求（值接收者）
func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 向响应写入问候信息
    fmt.Fprintf(w, "Hello, %s!\n", h.Name)
    fmt.Fprintf(w, "请求路径: %s\n", r.URL.Path)   // 输出请求路径
    fmt.Fprintf(w, "请求方法: %s\n", r.Method)     // 输出请求方法（GET、POST 等）
}

// CounterHandler 计数器处理器（实现 Handler 接口）
type CounterHandler struct {
    count int // 访问计数（需要修改，所以使用指针接收者）
}

// ServeHTTP 处理 HTTP 请求（指针接收者，需要修改计数器）
func (h *CounterHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    h.count++ // 每次访问计数加 1
    fmt.Fprintf(w, "访问次数: %d\n", h.count)
}

func main() {
    helloHandler := HelloHandler{Name: "Go"}
    counterHandler := &CounterHandler{}
    
    http.Handle("/hello", helloHandler)
    http.Handle("/counter", counterHandler)
    
    fmt.Println("服务器启动在 http://localhost:8080")
    fmt.Println("访问 http://localhost:8080/hello")
    fmt.Println("访问 http://localhost:8080/counter")
    
    http.ListenAndServe(":8080", nil)
}
```

### Demo 5: 插件系统

```go
package main

import "fmt"

// Plugin 插件接口：定义插件必须实现的方法
type Plugin interface {
    Name() string    // 返回插件名称
    Execute() error  // 执行插件逻辑
    Version() string // 返回插件版本
}

// PluginManager 插件管理器
type PluginManager struct {
    plugins []Plugin // 存储所有已注册的插件
}

// NewPluginManager 创建插件管理器
func NewPluginManager() *PluginManager {
    return &PluginManager{
        plugins: make([]Plugin, 0), // 初始化空插件列表
    }
}

// Register 注册插件
func (pm *PluginManager) Register(p Plugin) {
    pm.plugins = append(pm.plugins, p) // 添加到插件列表
}

// ExecuteAll 执行所有插件
func (pm *PluginManager) ExecuteAll() error {
    // 遍历所有插件
    for _, p := range pm.plugins {
        fmt.Printf("执行插件: %s (v%s)\n", p.Name(), p.Version())
        // 执行插件，如果失败则返回错误
        if err := p.Execute(); err != nil {
            return fmt.Errorf("插件 %s 执行失败: %v", p.Name(), err)
        }
    }
    return nil
}

// LogPlugin 日志插件实现（实现 Plugin 接口）
type LogPlugin struct{}

func (p LogPlugin) Name() string {
    return "日志插件"
}

func (p LogPlugin) Execute() error {
    fmt.Println("  记录日志...")
    return nil
}

func (p LogPlugin) Version() string {
    return "1.0.0"
}

// CachePlugin 缓存插件实现（实现 Plugin 接口）
type CachePlugin struct{}

func (p CachePlugin) Name() string {
    return "缓存插件"
}

func (p CachePlugin) Execute() error {
    fmt.Println("  清理缓存...")
    return nil
}

func (p CachePlugin) Version() string {
    return "2.0.0"
}

func main() {
    manager := NewPluginManager()
    
    manager.Register(LogPlugin{})
    manager.Register(CachePlugin{})
    
    if err := manager.ExecuteAll(); err != nil {
        fmt.Printf("错误: %v\n", err)
    }
}
```

### Demo 6: 类型断言的实际应用

```go
package main

import "fmt"

// Animal 动物接口
type Animal interface {
    Speak() string // 动物叫声
}

// Dog 狗结构体（实现 Animal 接口）
type Dog struct {
    Name string // 狗的名字
}

func (d Dog) Speak() string {
    return "汪汪"
}

// Fetch 捡球方法（Dog 特有的方法，不在接口中）
func (d Dog) Fetch() string {
    return "捡球"
}

// Cat 猫结构体（实现 Animal 接口）
type Cat struct {
    Name string // 猫的名字
}

func (c Cat) Speak() string {
    return "喵喵"
}

// Climb 爬树方法（Cat 特有的方法，不在接口中）
func (c Cat) Climb() string {
    return "爬树"
}

// handleAnimal 处理动物（演示类型断言和类型开关）
func handleAnimal(a Animal) {
    fmt.Printf("%s 说: %s\n", getAnimalName(a), a.Speak())
    
    // 类型断言：安全地检查是否是 Dog 类型
    // ok 为 true 表示断言成功，可以访问 Dog 特有的方法
    if dog, ok := a.(Dog); ok {
        fmt.Printf("  %s 会: %s\n", dog.Name, dog.Fetch()) // 调用 Dog 特有方法
    }
    
    // 类型开关（type switch）：根据实际类型执行不同逻辑
    switch v := a.(type) {
    case Dog:
        fmt.Printf("  这是一只狗: %s\n", v.Name)
    case Cat:
        fmt.Printf("  这是一只猫: %s\n", v.Name)
    default:
        fmt.Println("  未知动物")
    }
}

// getAnimalName 获取动物名称（使用类型开关）
func getAnimalName(a Animal) string {
    switch v := a.(type) {
    case Dog:
        return v.Name // 返回狗的名字
    case Cat:
        return v.Name // 返回猫的名字
    default:
        return "未知"
    }
}

func main() {
    animals := []Animal{
        Dog{Name: "旺财"},
        Cat{Name: "小花"},
        Dog{Name: "小黑"},
    }
    
    for _, animal := range animals {
        handleAnimal(animal)
        fmt.Println()
    }
}
```

## 接口最佳实践

1. **接口设计**：
   - 保持接口小而专注
   - 使用组合创建复杂接口
   - 接口应该表达行为，而不是数据

2. **实现原则**：
   - 接受接口，返回结构体
   - 避免不必要的接口

3. **空接口使用**：
   - 谨慎使用 `interface{}`
   - 优先使用具体类型或小接口

4. **类型断言**：
   - 使用安全类型断言 `value, ok := i.(Type)`
   - 使用类型开关处理多种类型

## 下一步

- [并发编程](./08-并发编程.md) - 学习 Goroutine 和 Channel

