# 接口

## 接口定义

### 基本语法

```go
type InterfaceName interface {
    Method1(param1 type1) returnType1
    Method2(param2 type2) returnType2
}
```

### 示例

```go
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}
```

**与其他语言对比**：
- **C++**: 没有专门的 `interface` 关键字，通常通过纯虚类（只含纯虚函数的 `class`）实现接口语义
- **Rust**: `trait`，类似但更强大
- **Java**: `interface`，类似但需要显式实现

**Go 特点**：
- 隐式实现（不需要 `implements` 关键字）
- 接口是类型
- 可以组合接口

## 接口实现

### 隐式实现

只要类型实现了接口的所有方法，就自动实现了该接口。

```go
type Shape interface {
    Area() float64
}

type Circle struct {
    Radius float64
}

// Circle 实现了 Shape 接口（隐式）
func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

type Rectangle struct {
    Width  float64
    Height float64
}

// Rectangle 也实现了 Shape 接口
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}
```

### 接口作为参数

```go
func printArea(s Shape) {
    fmt.Printf("面积: %.2f\n", s.Area())
}

// 使用
circle := Circle{Radius: 5}
rectangle := Rectangle{Width: 10, Height: 5}

printArea(circle)    // 面积: 78.50
printArea(rectangle) // 面积: 50.00
```

## 空接口

`interface{}` 可以表示任何类型。

```go
func printValue(v interface{}) {
    fmt.Printf("值: %v, 类型: %T\n", v, v)
}

printValue(42)        // int
printValue("hello")   // string
printValue(3.14)      // float64
```

Go 1.18+ 引入了 `any` 作为 `interface{}` 的别名：

```go
func printValue(v any) {  // 等同于 interface{}
    fmt.Printf("值: %v\n", v)
}
```

## 类型断言

### 基本语法

```go
var i interface{} = "hello"

s := i.(string)        // 类型断言
fmt.Println(s)         // hello

s, ok := i.(string)    // 安全类型断言
if ok {
    fmt.Println(s)
}
```

### 类型开关（Type Switch）

```go
func doSomething(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s\n", v)
    case bool:
        fmt.Printf("布尔值: %v\n", v)
    default:
        fmt.Printf("未知类型: %T\n", v)
    }
}
```

## 接口组合

接口可以组合，形成更大的接口。

```go
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type Closer interface {
    Close() error
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

## 实际应用场景 Demo

### Demo 1: 多态图形系统

```go
package main

import (
    "fmt"
    "math"
)

type Shape interface {
    Area() float64
    Perimeter() float64
    Name() string
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

func (c Circle) Name() string {
    return "圆形"
}

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

func (r Rectangle) Name() string {
    return "矩形"
}

func printShapeInfo(s Shape) {
    fmt.Printf("%s:\n", s.Name())
    fmt.Printf("  面积: %.2f\n", s.Area())
    fmt.Printf("  周长: %.2f\n", s.Perimeter())
    fmt.Println()
}

func calculateTotalArea(shapes []Shape) float64 {
    total := 0.0
    for _, s := range shapes {
        total += s.Area()
    }
    return total
}

func main() {
    shapes := []Shape{
        Circle{Radius: 5},
        Rectangle{Width: 10, Height: 5},
        Circle{Radius: 3},
        Rectangle{Width: 4, Height: 4},
    }
    
    for _, shape := range shapes {
        printShapeInfo(shape)
    }
    
    fmt.Printf("总面积: %.2f\n", calculateTotalArea(shapes))
}
```

### Demo 2: 数据存储接口

```go
package main

import (
    "fmt"
    "os"
)

type Storage interface {
    Save(key string, value []byte) error
    Load(key string) ([]byte, error)
    Delete(key string) error
}

// 内存存储实现
type MemoryStorage struct {
    data map[string][]byte
}

func NewMemoryStorage() *MemoryStorage {
    return &MemoryStorage{
        data: make(map[string][]byte),
    }
}

func (m *MemoryStorage) Save(key string, value []byte) error {
    m.data[key] = value
    return nil
}

func (m *MemoryStorage) Load(key string) ([]byte, error) {
    value, ok := m.data[key]
    if !ok {
        return nil, fmt.Errorf("key not found: %s", key)
    }
    return value, nil
}

func (m *MemoryStorage) Delete(key string) error {
    delete(m.data, key)
    return nil
}

// 文件存储实现
type FileStorage struct {
    baseDir string
}

func NewFileStorage(baseDir string) *FileStorage {
    os.MkdirAll(baseDir, 0755)
    return &FileStorage{baseDir: baseDir}
}

func (f *FileStorage) Save(key string, value []byte) error {
    filename := fmt.Sprintf("%s/%s", f.baseDir, key)
    return os.WriteFile(filename, value, 0644)
}

func (f *FileStorage) Load(key string) ([]byte, error) {
    filename := fmt.Sprintf("%s/%s", f.baseDir, key)
    return os.ReadFile(filename)
}

func (f *FileStorage) Delete(key string) error {
    filename := fmt.Sprintf("%s/%s", f.baseDir, key)
    return os.Remove(filename)
}

func useStorage(s Storage) {
    s.Save("key1", []byte("value1"))
    s.Save("key2", []byte("value2"))
    
    value, _ := s.Load("key1")
    fmt.Printf("加载 key1: %s\n", value)
    
    s.Delete("key2")
}

func main() {
    fmt.Println("使用内存存储:")
    memoryStorage := NewMemoryStorage()
    useStorage(memoryStorage)
    
    fmt.Println("\n使用文件存储:")
    fileStorage := NewFileStorage("./storage")
    useStorage(fileStorage)
}
```

### Demo 3: 排序接口

```go
package main

import (
    "fmt"
    "sort"
)

type Person struct {
    Name string
    Age  int
}

type ByAge []Person

func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

type ByName []Person

func (a ByName) Len() int           { return len(a) }
func (a ByName) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name }

func main() {
    people := []Person{
        {"Bob", 31},
        {"John", 42},
        {"Michael", 17},
        {"Jenny", 26},
    }
    
    fmt.Println("原始顺序:")
    for _, p := range people {
        fmt.Printf("%s (%d)\n", p.Name, p.Age)
    }
    
    fmt.Println("\n按年龄排序:")
    sort.Sort(ByAge(people))
    for _, p := range people {
        fmt.Printf("%s (%d)\n", p.Name, p.Age)
    }
    
    fmt.Println("\n按姓名排序:")
    sort.Sort(ByName(people))
    for _, p := range people {
        fmt.Printf("%s (%d)\n", p.Name, p.Age)
    }
}
```

### Demo 4: HTTP 处理器接口

```go
package main

import (
    "fmt"
    "net/http"
)

type Handler interface {
    ServeHTTP(http.ResponseWriter, *http.Request)
}

type HelloHandler struct {
    Name string
}

func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!\n", h.Name)
    fmt.Fprintf(w, "请求路径: %s\n", r.URL.Path)
    fmt.Fprintf(w, "请求方法: %s\n", r.Method)
}

type CounterHandler struct {
    count int
}

func (h *CounterHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    h.count++
    fmt.Fprintf(w, "访问次数: %d\n", h.count)
}

func main() {
    helloHandler := HelloHandler{Name: "Go"}
    counterHandler := &CounterHandler{}
    
    http.Handle("/hello", helloHandler)
    http.Handle("/counter", counterHandler)
    
    fmt.Println("服务器启动在 http://localhost:8080")
    fmt.Println("访问 http://localhost:8080/hello")
    fmt.Println("访问 http://localhost:8080/counter")
    
    http.ListenAndServe(":8080", nil)
}
```

### Demo 5: 插件系统

```go
package main

import "fmt"

type Plugin interface {
    Name() string
    Execute() error
    Version() string
}

type PluginManager struct {
    plugins []Plugin
}

func NewPluginManager() *PluginManager {
    return &PluginManager{
        plugins: make([]Plugin, 0),
    }
}

func (pm *PluginManager) Register(p Plugin) {
    pm.plugins = append(pm.plugins, p)
}

func (pm *PluginManager) ExecuteAll() error {
    for _, p := range pm.plugins {
        fmt.Printf("执行插件: %s (v%s)\n", p.Name(), p.Version())
        if err := p.Execute(); err != nil {
            return fmt.Errorf("插件 %s 执行失败: %v", p.Name(), err)
        }
    }
    return nil
}

// 插件实现1
type LogPlugin struct{}

func (p LogPlugin) Name() string {
    return "日志插件"
}

func (p LogPlugin) Execute() error {
    fmt.Println("  记录日志...")
    return nil
}

func (p LogPlugin) Version() string {
    return "1.0.0"
}

// 插件实现2
type CachePlugin struct{}

func (p CachePlugin) Name() string {
    return "缓存插件"
}

func (p CachePlugin) Execute() error {
    fmt.Println("  清理缓存...")
    return nil
}

func (p CachePlugin) Version() string {
    return "2.0.0"
}

func main() {
    manager := NewPluginManager()
    
    manager.Register(LogPlugin{})
    manager.Register(CachePlugin{})
    
    if err := manager.ExecuteAll(); err != nil {
        fmt.Printf("错误: %v\n", err)
    }
}
```

### Demo 6: 类型断言的实际应用

```go
package main

import "fmt"

type Animal interface {
    Speak() string
}

type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return "汪汪"
}

func (d Dog) Fetch() string {
    return "捡球"
}

type Cat struct {
    Name string
}

func (c Cat) Speak() string {
    return "喵喵"
}

func (c Cat) Climb() string {
    return "爬树"
}

func handleAnimal(a Animal) {
    fmt.Printf("%s 说: %s\n", getAnimalName(a), a.Speak())
    
    // 类型断言：检查是否是 Dog
    if dog, ok := a.(Dog); ok {
        fmt.Printf("  %s 会: %s\n", dog.Name, dog.Fetch())
    }
    
    // 类型开关
    switch v := a.(type) {
    case Dog:
        fmt.Printf("  这是一只狗: %s\n", v.Name)
    case Cat:
        fmt.Printf("  这是一只猫: %s\n", v.Name)
    default:
        fmt.Println("  未知动物")
    }
}

func getAnimalName(a Animal) string {
    switch v := a.(type) {
    case Dog:
        return v.Name
    case Cat:
        return v.Name
    default:
        return "未知"
    }
}

func main() {
    animals := []Animal{
        Dog{Name: "旺财"},
        Cat{Name: "小花"},
        Dog{Name: "小黑"},
    }
    
    for _, animal := range animals {
        handleAnimal(animal)
        fmt.Println()
    }
}
```

## 接口最佳实践

1. **接口设计**：
   - 保持接口小而专注
   - 使用组合创建复杂接口
   - 接口应该表达行为，而不是数据

2. **实现原则**：
   - 接受接口，返回结构体
   - 避免不必要的接口

3. **空接口使用**：
   - 谨慎使用 `interface{}`
   - 优先使用具体类型或小接口

4. **类型断言**：
   - 使用安全类型断言 `value, ok := i.(Type)`
   - 使用类型开关处理多种类型

## 下一步

- [并发编程](./08-并发编程.md) - 学习 Goroutine 和 Channel

