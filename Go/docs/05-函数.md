# 函数

## 函数定义

### 基本语法

```go
func functionName(parameter1 type1, parameter2 type2) returnType {
    // 函数体
    return value
}
```

### 示例

```go
func add(a int, b int) int {
    return a + b
}

// 参数类型相同可以简写
func multiply(a, b int) int {
    return a * b
}
```

**与其他语言对比**：
- **C++**: `int add(int a, int b) { return a + b; }`
- **Rust**: `fn add(a: i32, b: i32) -> i32 { a + b }`
- **Java**: `public int add(int a, int b) { return a + b; }`

**Go 特点**：
- 函数是一等公民（可以作为值传递）
- 支持多返回值
- 支持命名返回值

## 多返回值

Go 的一个特色功能是支持多返回值。

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为0")
    }
    return a / b, nil
}

// 使用
result, err := divide(10, 2)
if err != nil {
    fmt.Println("错误:", err)
} else {
    fmt.Println("结果:", result)
}
```

### 命名返回值

```go
func calculate(a, b int) (sum int, product int, difference int) {
    sum = a + b
    product = a * b
    difference = a - b
    return  // 自动返回命名变量
}

// 等价于
func calculate2(a, b int) (int, int, int) {
    sum := a + b
    product := a * b
    difference := a - b
    return sum, product, difference
}
```

**与其他语言对比**：
- **C++**: 不支持多返回值，通常通过 `std::pair`/`std::tuple` 或输出参数实现
- **Rust**: 支持元组返回 `(i32, i32)`
- **Java**: 不支持多返回值，需要对象或数组

## 可变参数

```go
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// 使用
result := sum(1, 2, 3, 4, 5)  // 15
result2 := sum()               // 0
```

**与其他语言对比**：
- **C++**: C 风格 `...` 可变参数（不安全），以及模板参数包（编译期多态）
- **Rust**: 不支持，使用切片
- **Java**: `...` 可变参数

## 函数作为值

函数是一等公民，可以作为值传递。

```go
func add(a, b int) int {
    return a + b
}

func multiply(a, b int) int {
    return a * b
}

func calculate(a, b int, op func(int, int) int) int {
    return op(a, b)
}

// 使用
result1 := calculate(5, 3, add)        // 8
result2 := calculate(5, 3, multiply)   // 15
```

## 匿名函数和闭包

### 匿名函数

```go
// 立即执行
func() {
    fmt.Println("匿名函数")
}()

// 赋值给变量
add := func(a, b int) int {
    return a + b
}
result := add(3, 4)
```

### 闭包

闭包可以捕获外部变量。

```go
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// 使用
c1 := counter()
fmt.Println(c1())  // 1
fmt.Println(c1())  // 2
fmt.Println(c1())  // 3

c2 := counter()
fmt.Println(c2())  // 1（新的计数器）
```

**与其他语言对比**：
- **C++**: C++11 起支持 Lambda 和捕获列表
- **Rust**: 支持闭包，语法类似
- **Java**: Java 8+ 支持 Lambda 表达式

## defer 语句

`defer` 用于延迟执行，常用于资源清理。

```go
func example() {
    file, err := os.Open("file.txt")
    if err != nil {
        return
    }
    defer file.Close()  // 函数返回时执行
    
    // 使用 file
}
```

### defer 执行顺序

多个 `defer` 按 LIFO（后进先出）顺序执行。

```go
func example() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
    // 输出: 3, 2, 1
}
```

### defer 与返回值

```go
func example() (result int) {
    defer func() {
        result++  // 修改返回值
    }()
    return 0  // 实际返回 1
}
```

**与其他语言对比**：
- **C++**: 通过 RAII（构造/析构函数）实现自动资源管理
- **Rust**: `Drop` trait，自动调用析构函数
- **Java**: `try-with-resources`，自动资源管理

## 方法

方法是带有接收者的函数。

```go
type Rectangle struct {
    Width  float64
    Height float64
}

// 值接收者
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// 指针接收者
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}
```

（详细内容见 [结构体和方法](./06-结构体和方法.md) 章节）

## 实际应用场景 Demo

### Demo 1: 计算器工具函数

```go
package main

import (
    "fmt"
    "math"
)

// 基本运算
func add(a, b float64) float64 {
    return a + b
}

func subtract(a, b float64) float64 {
    return a - b
}

func multiply(a, b float64) float64 {
    return a * b
}

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为0")
    }
    return a / b, nil
}

// 高级运算
func power(base, exponent float64) float64 {
    return math.Pow(base, exponent)
}

func sqrt(x float64) (float64, error) {
    if x < 0 {
        return 0, fmt.Errorf("不能对负数开平方")
    }
    return math.Sqrt(x), nil
}

// 使用函数作为值
type Operation func(float64, float64) float64

func calculate(a, b float64, op Operation) float64 {
    return op(a, b)
}

func main() {
    // 基本运算
    fmt.Printf("10 + 5 = %.2f\n", add(10, 5))
    fmt.Printf("10 - 5 = %.2f\n", subtract(10, 5))
    fmt.Printf("10 * 5 = %.2f\n", multiply(10, 5))
    
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("错误:", err)
    } else {
        fmt.Printf("10 / 2 = %.2f\n", result)
    }
    
    // 高级运算
    fmt.Printf("2^8 = %.2f\n", power(2, 8))
    
    sqrtResult, err := sqrt(16)
    if err != nil {
        fmt.Println("错误:", err)
    } else {
        fmt.Printf("√16 = %.2f\n", sqrtResult)
    }
    
    // 使用函数作为值
    fmt.Printf("使用函数值: %.2f\n", calculate(10, 5, multiply))
}
```

### Demo 2: 文件操作工具

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
)

func readFile(filename string) (string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer file.Close()  // 确保文件关闭
    
    content, err := ioutil.ReadAll(file)
    if err != nil {
        return "", err
    }
    
    return string(content), nil
}

func writeFile(filename, content string) error {
    file, err := os.Create(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // 确保文件关闭
    
    _, err = file.WriteString(content)
    return err
}

func copyFile(src, dst string) error {
    content, err := readFile(src)
    if err != nil {
        return fmt.Errorf("读取源文件失败: %v", err)
    }
    
    err = writeFile(dst, content)
    if err != nil {
        return fmt.Errorf("写入目标文件失败: %v", err)
    }
    
    return nil
}

func main() {
    // 写入文件
    err := writeFile("test.txt", "Hello, Go!")
    if err != nil {
        fmt.Printf("写入失败: %v\n", err)
        return
    }
    
    // 读取文件
    content, err := readFile("test.txt")
    if err != nil {
        fmt.Printf("读取失败: %v\n", err)
        return
    }
    fmt.Printf("文件内容: %s\n", content)
    
    // 复制文件
    err = copyFile("test.txt", "test_copy.txt")
    if err != nil {
        fmt.Printf("复制失败: %v\n", err)
    } else {
        fmt.Println("文件复制成功")
    }
}
```

### Demo 3: 函数式编程示例

```go
package main

import "fmt"

// Map: 对切片中每个元素应用函数
func mapInt(slice []int, fn func(int) int) []int {
    result := make([]int, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Filter: 过滤切片
func filterInt(slice []int, fn func(int) bool) []int {
    result := make([]int, 0)
    for _, v := range slice {
        if fn(v) {
            result = append(result, v)
        }
    }
    return result
}

// Reduce: 归约切片
func reduceInt(slice []int, initial int, fn func(int, int) int) int {
    result := initial
    for _, v := range slice {
        result = fn(result, v)
    }
    return result
}

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    // Map: 每个数乘以2
    doubled := mapInt(numbers, func(x int) int {
        return x * 2
    })
    fmt.Printf("翻倍: %v\n", doubled)
    
    // Filter: 过滤偶数
    evens := filterInt(numbers, func(x int) bool {
        return x%2 == 0
    })
    fmt.Printf("偶数: %v\n", evens)
    
    // Reduce: 求和
    sum := reduceInt(numbers, 0, func(acc, x int) int {
        return acc + x
    })
    fmt.Printf("求和: %d\n", sum)
    
    // Reduce: 求积
    product := reduceInt(numbers, 1, func(acc, x int) int {
        return acc * x
    })
    fmt.Printf("求积: %d\n", product)
}
```

### Demo 4: 闭包应用：缓存函数

```go
package main

import (
    "fmt"
    "time"
)

// 创建一个带缓存的函数
func cachedFunction(fn func(int) int) func(int) int {
    cache := make(map[int]int)
    
    return func(n int) int {
        if val, ok := cache[n]; ok {
            fmt.Printf("缓存命中: %d\n", n)
            return val
        }
        
        fmt.Printf("计算: %d\n", n)
        result := fn(n)
        cache[n] = result
        return result
    }
}

// 模拟耗时计算
func expensiveCalculation(n int) int {
    time.Sleep(100 * time.Millisecond)
    return n * n
}

func main() {
    cachedCalc := cachedFunction(expensiveCalculation)
    
    fmt.Println("第一次调用:")
    result1 := cachedCalc(5)
    fmt.Printf("结果: %d\n\n", result1)
    
    fmt.Println("第二次调用（应该使用缓存）:")
    result2 := cachedCalc(5)
    fmt.Printf("结果: %d\n\n", result2)
    
    fmt.Println("计算新值:")
    result3 := cachedCalc(10)
    fmt.Printf("结果: %d\n", result3)
}
```

### Demo 5: 错误处理和重试机制

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

func retryOperation(fn func() error, maxRetries int, delay time.Duration) error {
    var lastErr error
    
    for i := 0; i < maxRetries; i++ {
        err := fn()
        if err == nil {
            return nil
        }
        
        lastErr = err
        if i < maxRetries-1 {
            fmt.Printf("重试 %d/%d: %v\n", i+1, maxRetries, err)
            time.Sleep(delay)
        }
    }
    
    return fmt.Errorf("操作失败，已重试 %d 次: %v", maxRetries, lastErr)
}

func simulateUnreliableOperation() error {
    // 模拟随机失败
    if time.Now().Unix()%3 == 0 {
        return errors.New("操作失败")
    }
    return nil
}

func main() {
    err := retryOperation(simulateUnreliableOperation, 3, time.Second)
    if err != nil {
        fmt.Printf("最终失败: %v\n", err)
    } else {
        fmt.Println("操作成功")
    }
}
```

## 函数最佳实践

1. **函数命名**：
   - 使用驼峰命名
   - 导出函数首字母大写
   - 函数名应该清晰表达功能

2. **参数设计**：
   - 参数不宜过多（超过 3-4 个考虑使用结构体）
   - 使用多返回值处理错误

3. **defer 使用**：
   - 用于资源清理（文件、锁等）
   - 注意 defer 的执行时机

4. **闭包使用**：
   - 注意变量捕获的时机
   - 避免循环中的闭包陷阱

## 下一步

- [结构体和方法](./06-结构体和方法.md) - 学习面向对象编程

