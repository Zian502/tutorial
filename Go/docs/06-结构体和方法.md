# 结构体和方法

## 结构体定义

### 基本语法

```go
type StructName struct {
    Field1 type1
    Field2 type2
    Field3 type3
}
```

### 示例

```go
type Person struct {
    Name string
    Age  int
    City string
}

// 创建实例
p1 := Person{"Alice", 30, "Beijing"}
p2 := Person{Name: "Bob", Age: 25}
p3 := Person{}  // 所有字段为零值
```

**与其他语言对比**：
- **C++**: `struct Person { std::string name; int age; };` 或 `class Person { ... };`
- **Rust**: `struct Person { name: String, age: i32 }`
- **Java**: `class Person { String name; int age; }`

**Go 特点**：
- 结构体是值类型（赋值会复制）
- 没有类继承，使用组合
- 支持方法（不是成员函数）

## 结构体字段

### 字段访问

```go
p := Person{Name: "Alice", Age: 30}
fmt.Println(p.Name)  // 访问字段
p.Age = 31           // 修改字段
```

### 匿名字段（嵌入）

```go
type Address struct {
    Street string
    City   string
}

type Person struct {
    Name string
    Age  int
    Address  // 匿名字段，可以直接访问
}

p := Person{
    Name: "Alice",
    Age:  30,
    Address: Address{
        Street: "123 Main St",
        City:   "Beijing",
    },
}

fmt.Println(p.City)        // 直接访问嵌入的字段
fmt.Println(p.Address.City) // 也可以完整路径访问
```

### 字段标签（Tag）

```go
type User struct {
    ID    int    `json:"id" db:"user_id"`
    Name  string `json:"name" db:"user_name"`
    Email string `json:"email" db:"email"`
}
```

标签用于元数据，常用于 JSON 序列化、数据库映射等。

## 方法

方法是带有接收者的函数。

### 值接收者

```go
type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// 使用
rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()
```

### 指针接收者

```go
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

func (r *Rectangle) SetWidth(width float64) {
    r.Width = width
}

// 使用
rect := Rectangle{Width: 10, Height: 5}
rect.Scale(2)  // 修改原结构体
```

### 何时使用值接收者 vs 指针接收者

- **值接收者**：不修改结构体，或结构体很小
- **指针接收者**：需要修改结构体，或结构体很大（避免复制）

```go
// 值接收者：不修改，只读取
func (r Rectangle) Area() float64 { ... }

// 指针接收者：需要修改
func (r *Rectangle) Scale(factor float64) { ... }
```

**与其他语言对比**：
- **C++**: 成员函数定义在 `struct`/`class` 中
- **Rust**: `impl` 块定义方法，类似
- **Java**: 类的方法，`this` 隐式参数

## 方法集

Go 的方法集规则：

```go
type T struct { ... }

// 值接收者方法
func (t T) Method1() { ... }

// 指针接收者方法
func (t *T) Method2() { ... }

var t T
var pt *T = &t

t.Method1()   // ✅ 可以调用
t.Method2()   // ✅ 可以调用（Go 自动转换）
pt.Method1()  // ✅ 可以调用（Go 自动解引用）
pt.Method2()  // ✅ 可以调用
```

## 实际应用场景 Demo

### Demo 1: 银行账户系统

```go
package main

import (
    "errors"
    "fmt"
)

// Account 银行账户结构体
type Account struct {
    AccountNumber string  // 账户号码
    Balance       float64 // 账户余额
    Owner         string  // 账户所有者
}

// NewAccount 创建新账户（构造函数）
// 返回指针类型，便于后续修改
func NewAccount(accountNumber, owner string) *Account {
    return &Account{
        AccountNumber: accountNumber,
        Balance:       0.0, // 初始余额为 0
        Owner:         owner,
    }
}

// Deposit 存款方法（指针接收者，需要修改账户余额）
func (a *Account) Deposit(amount float64) error {
    // 验证存款金额
    if amount <= 0 {
        return errors.New("存款金额必须大于0")
    }
    a.Balance += amount // 增加余额
    return nil
}

// Withdraw 取款方法（指针接收者，需要修改账户余额）
func (a *Account) Withdraw(amount float64) error {
    // 验证取款金额
    if amount <= 0 {
        return errors.New("取款金额必须大于0")
    }
    // 检查余额是否充足
    if amount > a.Balance {
        return errors.New("余额不足")
    }
    a.Balance -= amount // 减少余额
    return nil
}

// GetBalance 查询余额方法（值接收者，只读取不修改）
func (a Account) GetBalance() float64 {
    return a.Balance
}

// Transfer 转账方法（从一个账户转到另一个账户）
func (a *Account) Transfer(to *Account, amount float64) error {
    // 先从当前账户取款
    if err := a.Withdraw(amount); err != nil {
        return err
    }
    // 再向目标账户存款
    return to.Deposit(amount)
}

func main() {
    // 创建账户
    alice := NewAccount("ACC001", "Alice")
    bob := NewAccount("ACC002", "Bob")
    
    // 存款
    alice.Deposit(1000)
    bob.Deposit(500)
    
    fmt.Printf("%s 余额: %.2f\n", alice.Owner, alice.GetBalance())
    fmt.Printf("%s 余额: %.2f\n", bob.Owner, bob.GetBalance())
    
    // 转账
    err := alice.Transfer(bob, 200)
    if err != nil {
        fmt.Printf("转账失败: %v\n", err)
    } else {
        fmt.Println("\n转账成功")
        fmt.Printf("%s 余额: %.2f\n", alice.Owner, alice.GetBalance())
        fmt.Printf("%s 余额: %.2f\n", bob.Owner, bob.GetBalance())
    }
}
```

### Demo 2: 几何图形计算

```go
package main

import (
    "fmt"
    "math"
)

// Shape 接口定义（下一章会详细讲解）
// 接口定义了形状必须实现的方法
type Shape interface {
    Area() float64      // 计算面积
    Perimeter() float64 // 计算周长
}

// Circle 圆形结构体
type Circle struct {
    Radius float64 // 半径
}

// Area 计算圆形面积（值接收者，不修改结构体）
func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius // π * r²
}

// Perimeter 计算圆形周长
func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius // 2 * π * r
}

// Rectangle 矩形结构体
type Rectangle struct {
    Width  float64 // 宽度
    Height float64 // 高度
}

// Area 计算矩形面积
func (r Rectangle) Area() float64 {
    return r.Width * r.Height // 宽 * 高
}

// Perimeter 计算矩形周长
func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height) // 2 * (宽 + 高)
}

// Triangle 三角形结构体
type Triangle struct {
    A, B, C float64 // 三边长
}

// Area 计算三角形面积（使用海伦公式）
func (t Triangle) Area() float64 {
    // 海伦公式：S = √[s(s-a)(s-b)(s-c)]，其中 s = (a+b+c)/2
    s := t.Perimeter() / 2 // 半周长
    return math.Sqrt(s * (s - t.A) * (s - t.B) * (s - t.C))
}

// Perimeter 计算三角形周长
func (t Triangle) Perimeter() float64 {
    return t.A + t.B + t.C // 三边之和
}

// printShapeInfo 打印形状信息（接受 Shape 接口类型，实现多态）
func printShapeInfo(s Shape, name string) {
    fmt.Printf("%s:\n", name)
    fmt.Printf("  面积: %.2f\n", s.Area())      // 调用接口方法
    fmt.Printf("  周长: %.2f\n", s.Perimeter()) // 调用接口方法
    fmt.Println()
}

func main() {
    circle := Circle{Radius: 5}
    rectangle := Rectangle{Width: 10, Height: 5}
    triangle := Triangle{A: 3, B: 4, C: 5}
    
    printShapeInfo(circle, "圆形")
    printShapeInfo(rectangle, "矩形")
    printShapeInfo(triangle, "三角形")
}
```

### Demo 3: 学生管理系统（完整版）

```go
package main

import (
    "fmt"
    "sort"
)

type Student struct {
    ID    int
    Name  string
    Score float64
}

type StudentManager struct {
    students []Student
}

func NewStudentManager() *StudentManager {
    return &StudentManager{
        students: make([]Student, 0),
    }
}

func (sm *StudentManager) AddStudent(s Student) {
    sm.students = append(sm.students, s)
}

// RemoveStudent 根据 ID 删除学生
func (sm *StudentManager) RemoveStudent(id int) bool {
    // 遍历查找要删除的学生
    for i, s := range sm.students {
        if s.ID == id {
            // 使用切片操作删除元素：将 i 之前和 i+1 之后的元素拼接
            sm.students = append(sm.students[:i], sm.students[i+1:]...)
            return true // 删除成功
        }
    }
    return false // 未找到
}

// FindByID 根据 ID 查找学生
func (sm *StudentManager) FindByID(id int) *Student {
    // 遍历查找
    for i := range sm.students {
        if sm.students[i].ID == id {
            return &sm.students[i] // 返回找到的学生的指针
        }
    }
    return nil // 未找到
}

// SortByScore 按分数从高到低排序
func (sm *StudentManager) SortByScore() {
    // 使用 sort.Slice 自定义排序
    sort.Slice(sm.students, func(i, j int) bool {
        // 返回 true 表示 i 应该在 j 前面（分数高的在前）
        return sm.students[i].Score > sm.students[j].Score
    })
}

// GetAverageScore 计算平均分
func (sm *StudentManager) GetAverageScore() float64 {
    // 检查是否有学生
    if len(sm.students) == 0 {
        return 0
    }
    
    // 累加所有分数
    total := 0.0
    for _, s := range sm.students {
        total += s.Score
    }
    // 计算平均值
    return total / float64(len(sm.students))
}

func (sm StudentManager) PrintAll() {
    fmt.Println("=== 学生列表 ===")
    for _, s := range sm.students {
        fmt.Printf("ID: %d, 姓名: %s, 分数: %.2f\n", s.ID, s.Name, s.Score)
    }
    fmt.Printf("平均分: %.2f\n", sm.GetAverageScore())
    fmt.Println()
}

func main() {
    sm := NewStudentManager()
    
    // 添加学生
    sm.AddStudent(Student{ID: 1, Name: "张三", Score: 85.5})
    sm.AddStudent(Student{ID: 2, Name: "李四", Score: 92.0})
    sm.AddStudent(Student{ID: 3, Name: "王五", Score: 78.5})
    sm.AddStudent(Student{ID: 4, Name: "赵六", Score: 88.0})
    
    sm.PrintAll()
    
    // 查找学生
    s := sm.FindByID(2)
    if s != nil {
        fmt.Printf("找到学生: %s, 分数: %.2f\n\n", s.Name, s.Score)
    }
    
    // 排序
    sm.SortByScore()
    fmt.Println("按分数排序后:")
    sm.PrintAll()
    
    // 删除学生
    sm.RemoveStudent(3)
    fmt.Println("删除 ID=3 的学生后:")
    sm.PrintAll()
}
```

### Demo 4: 链表实现

```go
package main

import "fmt"

// Node 链表节点结构体
type Node struct {
    Value int   // 节点值
    Next  *Node // 指向下一个节点的指针
}

// LinkedList 链表结构体
type LinkedList struct {
    Head *Node // 头节点指针
}

// NewLinkedList 创建新链表
func NewLinkedList() *LinkedList {
    return &LinkedList{Head: nil} // 初始为空链表
}

// Append 在链表末尾添加节点
func (ll *LinkedList) Append(value int) {
    newNode := &Node{Value: value, Next: nil}
    
    // 如果链表为空，新节点成为头节点
    if ll.Head == nil {
        ll.Head = newNode
        return
    }
    
    // 遍历到链表末尾
    current := ll.Head
    for current.Next != nil {
        current = current.Next
    }
    // 在末尾添加新节点
    current.Next = newNode
}

// Prepend 在链表头部添加节点
func (ll *LinkedList) Prepend(value int) {
    // 新节点的 Next 指向原头节点
    newNode := &Node{Value: value, Next: ll.Head}
    // 新节点成为新的头节点
    ll.Head = newNode
}

// Delete 删除指定值的节点
func (ll *LinkedList) Delete(value int) bool {
    // 链表为空
    if ll.Head == nil {
        return false
    }
    
    // 如果要删除的是头节点
    if ll.Head.Value == value {
        ll.Head = ll.Head.Next // 头节点指向下一个节点
        return true
    }
    
    // 查找要删除的节点
    current := ll.Head
    for current.Next != nil {
        if current.Next.Value == value {
            // 跳过要删除的节点
            current.Next = current.Next.Next
            return true
        }
        current = current.Next
    }
    
    return false // 未找到
}

// Print 打印链表所有节点
func (ll LinkedList) Print() {
    current := ll.Head
    // 遍历链表
    for current != nil {
        fmt.Printf("%d -> ", current.Value)
        current = current.Next
    }
    fmt.Println("nil") // 链表结束
}

// Length 计算链表长度
func (ll LinkedList) Length() int {
    count := 0
    current := ll.Head
    // 遍历计数
    for current != nil {
        count++
        current = current.Next
    }
    return count
}

func main() {
    ll := NewLinkedList()
    
    ll.Append(1)
    ll.Append(2)
    ll.Append(3)
    ll.Prepend(0)
    
    fmt.Printf("链表长度: %d\n", ll.Length())
    ll.Print()
    
    ll.Delete(2)
    fmt.Println("删除 2 后:")
    ll.Print()
}
```

### Demo 5: JSON 序列化

```go
package main

import (
    "encoding/json"
    "fmt"
)

// User 用户结构体
// 使用 json 标签控制序列化行为
type User struct {
    ID       int    `json:"id"`       // JSON 字段名为 "id"
    Username string `json:"username"` // JSON 字段名为 "username"
    Email    string `json:"email"`    // JSON 字段名为 "email"
    Password string `json:"-"`       // "-" 表示不序列化此字段（保护敏感信息）
}

// ToJSON 将用户结构体序列化为 JSON 字符串
// 值接收者，不修改结构体
func (u User) ToJSON() (string, error) {
    // json.Marshal 将结构体转换为 JSON 字节数组
    data, err := json.Marshal(u)
    if err != nil {
        return "", err
    }
    // 转换为字符串返回
    return string(data), nil
}

// FromJSON 从 JSON 字符串反序列化为用户结构体
// 指针接收者，需要修改结构体
func (u *User) FromJSON(data string) error {
    // json.Unmarshal 将 JSON 字节数组解析到结构体
    return json.Unmarshal([]byte(data), u)
}

func main() {
    user := User{
        ID:       1,
        Username: "alice",
        Email:    "alice@example.com",
        Password: "secret123",
    }
    
    // 序列化
    jsonStr, err := user.ToJSON()
    if err != nil {
        fmt.Printf("序列化失败: %v\n", err)
        return
    }
    fmt.Printf("JSON: %s\n", jsonStr)
    
    // 反序列化
    var newUser User
    err = newUser.FromJSON(jsonStr)
    if err != nil {
        fmt.Printf("反序列化失败: %v\n", err)
        return
    }
    fmt.Printf("用户: %+v\n", newUser)
}
```

## 结构体和方法最佳实践

1. **结构体设计**：
   - 使用大写字母开头的字段名（导出）
   - 使用标签进行元数据标注
   - 考虑使用嵌入实现组合

2. **方法设计**：
   - 值接收者：不修改结构体
   - 指针接收者：需要修改结构体
   - 保持方法集的一致性

3. **构造函数**：
   - 使用 `NewXxx` 命名约定
   - 返回指针类型便于修改

## 下一步

- [接口](./07-接口.md) - 学习接口和多态

