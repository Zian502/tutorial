# 结构体和方法

## 结构体定义

### 基本语法

```go
type StructName struct {
    Field1 type1
    Field2 type2
    Field3 type3
}
```

### 示例

```go
type Person struct {
    Name string
    Age  int
    City string
}

// 创建实例
p1 := Person{"Alice", 30, "Beijing"}
p2 := Person{Name: "Bob", Age: 25}
p3 := Person{}  // 所有字段为零值
```

**与其他语言对比**：
- **C++**: `struct Person { std::string name; int age; };` 或 `class Person { ... };`
- **Rust**: `struct Person { name: String, age: i32 }`
- **Java**: `class Person { String name; int age; }`

**Go 特点**：
- 结构体是值类型（赋值会复制）
- 没有类继承，使用组合
- 支持方法（不是成员函数）

## 结构体字段

### 字段访问

```go
p := Person{Name: "Alice", Age: 30}
fmt.Println(p.Name)  // 访问字段
p.Age = 31           // 修改字段
```

### 匿名字段（嵌入）

```go
type Address struct {
    Street string
    City   string
}

type Person struct {
    Name string
    Age  int
    Address  // 匿名字段，可以直接访问
}

p := Person{
    Name: "Alice",
    Age:  30,
    Address: Address{
        Street: "123 Main St",
        City:   "Beijing",
    },
}

fmt.Println(p.City)        // 直接访问嵌入的字段
fmt.Println(p.Address.City) // 也可以完整路径访问
```

### 字段标签（Tag）

```go
type User struct {
    ID    int    `json:"id" db:"user_id"`
    Name  string `json:"name" db:"user_name"`
    Email string `json:"email" db:"email"`
}
```

标签用于元数据，常用于 JSON 序列化、数据库映射等。

## 方法

方法是带有接收者的函数。

### 值接收者

```go
type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// 使用
rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()
```

### 指针接收者

```go
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

func (r *Rectangle) SetWidth(width float64) {
    r.Width = width
}

// 使用
rect := Rectangle{Width: 10, Height: 5}
rect.Scale(2)  // 修改原结构体
```

### 何时使用值接收者 vs 指针接收者

- **值接收者**：不修改结构体，或结构体很小
- **指针接收者**：需要修改结构体，或结构体很大（避免复制）

```go
// 值接收者：不修改，只读取
func (r Rectangle) Area() float64 { ... }

// 指针接收者：需要修改
func (r *Rectangle) Scale(factor float64) { ... }
```

**与其他语言对比**：
- **C++**: 成员函数定义在 `struct`/`class` 中
- **Rust**: `impl` 块定义方法，类似
- **Java**: 类的方法，`this` 隐式参数

## 方法集

Go 的方法集规则：

```go
type T struct { ... }

// 值接收者方法
func (t T) Method1() { ... }

// 指针接收者方法
func (t *T) Method2() { ... }

var t T
var pt *T = &t

t.Method1()   // ✅ 可以调用
t.Method2()   // ✅ 可以调用（Go 自动转换）
pt.Method1()  // ✅ 可以调用（Go 自动解引用）
pt.Method2()  // ✅ 可以调用
```

## 实际应用场景 Demo

### Demo 1: 银行账户系统

```go
package main

import (
    "errors"
    "fmt"
)

type Account struct {
    AccountNumber string
    Balance       float64
    Owner         string
}

// 创建账户
func NewAccount(accountNumber, owner string) *Account {
    return &Account{
        AccountNumber: accountNumber,
        Balance:       0.0,
        Owner:         owner,
    }
}

// 存款
func (a *Account) Deposit(amount float64) error {
    if amount <= 0 {
        return errors.New("存款金额必须大于0")
    }
    a.Balance += amount
    return nil
}

// 取款
func (a *Account) Withdraw(amount float64) error {
    if amount <= 0 {
        return errors.New("取款金额必须大于0")
    }
    if amount > a.Balance {
        return errors.New("余额不足")
    }
    a.Balance -= amount
    return nil
}

// 查询余额
func (a Account) GetBalance() float64 {
    return a.Balance
}

// 转账
func (a *Account) Transfer(to *Account, amount float64) error {
    if err := a.Withdraw(amount); err != nil {
        return err
    }
    return to.Deposit(amount)
}

func main() {
    // 创建账户
    alice := NewAccount("ACC001", "Alice")
    bob := NewAccount("ACC002", "Bob")
    
    // 存款
    alice.Deposit(1000)
    bob.Deposit(500)
    
    fmt.Printf("%s 余额: %.2f\n", alice.Owner, alice.GetBalance())
    fmt.Printf("%s 余额: %.2f\n", bob.Owner, bob.GetBalance())
    
    // 转账
    err := alice.Transfer(bob, 200)
    if err != nil {
        fmt.Printf("转账失败: %v\n", err)
    } else {
        fmt.Println("\n转账成功")
        fmt.Printf("%s 余额: %.2f\n", alice.Owner, alice.GetBalance())
        fmt.Printf("%s 余额: %.2f\n", bob.Owner, bob.GetBalance())
    }
}
```

### Demo 2: 几何图形计算

```go
package main

import (
    "fmt"
    "math"
)

// 接口定义（下一章会详细讲解）
type Shape interface {
    Area() float64
    Perimeter() float64
}

// 圆形
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

// 矩形
type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// 三角形
type Triangle struct {
    A, B, C float64  // 三边长
}

func (t Triangle) Area() float64 {
    // 海伦公式
    s := t.Perimeter() / 2
    return math.Sqrt(s * (s - t.A) * (s - t.B) * (s - t.C))
}

func (t Triangle) Perimeter() float64 {
    return t.A + t.B + t.C
}

func printShapeInfo(s Shape, name string) {
    fmt.Printf("%s:\n", name)
    fmt.Printf("  面积: %.2f\n", s.Area())
    fmt.Printf("  周长: %.2f\n", s.Perimeter())
    fmt.Println()
}

func main() {
    circle := Circle{Radius: 5}
    rectangle := Rectangle{Width: 10, Height: 5}
    triangle := Triangle{A: 3, B: 4, C: 5}
    
    printShapeInfo(circle, "圆形")
    printShapeInfo(rectangle, "矩形")
    printShapeInfo(triangle, "三角形")
}
```

### Demo 3: 学生管理系统（完整版）

```go
package main

import (
    "fmt"
    "sort"
)

type Student struct {
    ID    int
    Name  string
    Score float64
}

type StudentManager struct {
    students []Student
}

func NewStudentManager() *StudentManager {
    return &StudentManager{
        students: make([]Student, 0),
    }
}

func (sm *StudentManager) AddStudent(s Student) {
    sm.students = append(sm.students, s)
}

func (sm *StudentManager) RemoveStudent(id int) bool {
    for i, s := range sm.students {
        if s.ID == id {
            sm.students = append(sm.students[:i], sm.students[i+1:]...)
            return true
        }
    }
    return false
}

func (sm *StudentManager) FindByID(id int) *Student {
    for i := range sm.students {
        if sm.students[i].ID == id {
            return &sm.students[i]
        }
    }
    return nil
}

func (sm *StudentManager) SortByScore() {
    sort.Slice(sm.students, func(i, j int) bool {
        return sm.students[i].Score > sm.students[j].Score
    })
}

func (sm *StudentManager) GetAverageScore() float64 {
    if len(sm.students) == 0 {
        return 0
    }
    
    total := 0.0
    for _, s := range sm.students {
        total += s.Score
    }
    return total / float64(len(sm.students))
}

func (sm StudentManager) PrintAll() {
    fmt.Println("=== 学生列表 ===")
    for _, s := range sm.students {
        fmt.Printf("ID: %d, 姓名: %s, 分数: %.2f\n", s.ID, s.Name, s.Score)
    }
    fmt.Printf("平均分: %.2f\n", sm.GetAverageScore())
    fmt.Println()
}

func main() {
    sm := NewStudentManager()
    
    // 添加学生
    sm.AddStudent(Student{ID: 1, Name: "张三", Score: 85.5})
    sm.AddStudent(Student{ID: 2, Name: "李四", Score: 92.0})
    sm.AddStudent(Student{ID: 3, Name: "王五", Score: 78.5})
    sm.AddStudent(Student{ID: 4, Name: "赵六", Score: 88.0})
    
    sm.PrintAll()
    
    // 查找学生
    s := sm.FindByID(2)
    if s != nil {
        fmt.Printf("找到学生: %s, 分数: %.2f\n\n", s.Name, s.Score)
    }
    
    // 排序
    sm.SortByScore()
    fmt.Println("按分数排序后:")
    sm.PrintAll()
    
    // 删除学生
    sm.RemoveStudent(3)
    fmt.Println("删除 ID=3 的学生后:")
    sm.PrintAll()
}
```

### Demo 4: 链表实现

```go
package main

import "fmt"

type Node struct {
    Value int
    Next  *Node
}

type LinkedList struct {
    Head *Node
}

func NewLinkedList() *LinkedList {
    return &LinkedList{Head: nil}
}

func (ll *LinkedList) Append(value int) {
    newNode := &Node{Value: value, Next: nil}
    
    if ll.Head == nil {
        ll.Head = newNode
        return
    }
    
    current := ll.Head
    for current.Next != nil {
        current = current.Next
    }
    current.Next = newNode
}

func (ll *LinkedList) Prepend(value int) {
    newNode := &Node{Value: value, Next: ll.Head}
    ll.Head = newNode
}

func (ll *LinkedList) Delete(value int) bool {
    if ll.Head == nil {
        return false
    }
    
    if ll.Head.Value == value {
        ll.Head = ll.Head.Next
        return true
    }
    
    current := ll.Head
    for current.Next != nil {
        if current.Next.Value == value {
            current.Next = current.Next.Next
            return true
        }
        current = current.Next
    }
    
    return false
}

func (ll LinkedList) Print() {
    current := ll.Head
    for current != nil {
        fmt.Printf("%d -> ", current.Value)
        current = current.Next
    }
    fmt.Println("nil")
}

func (ll LinkedList) Length() int {
    count := 0
    current := ll.Head
    for current != nil {
        count++
        current = current.Next
    }
    return count
}

func main() {
    ll := NewLinkedList()
    
    ll.Append(1)
    ll.Append(2)
    ll.Append(3)
    ll.Prepend(0)
    
    fmt.Printf("链表长度: %d\n", ll.Length())
    ll.Print()
    
    ll.Delete(2)
    fmt.Println("删除 2 后:")
    ll.Print()
}
```

### Demo 5: JSON 序列化

```go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
    Password string `json:"-"`  // 不序列化
}

func (u User) ToJSON() (string, error) {
    data, err := json.Marshal(u)
    if err != nil {
        return "", err
    }
    return string(data), nil
}

func (u *User) FromJSON(data string) error {
    return json.Unmarshal([]byte(data), u)
}

func main() {
    user := User{
        ID:       1,
        Username: "alice",
        Email:    "alice@example.com",
        Password: "secret123",
    }
    
    // 序列化
    jsonStr, err := user.ToJSON()
    if err != nil {
        fmt.Printf("序列化失败: %v\n", err)
        return
    }
    fmt.Printf("JSON: %s\n", jsonStr)
    
    // 反序列化
    var newUser User
    err = newUser.FromJSON(jsonStr)
    if err != nil {
        fmt.Printf("反序列化失败: %v\n", err)
        return
    }
    fmt.Printf("用户: %+v\n", newUser)
}
```

## 结构体和方法最佳实践

1. **结构体设计**：
   - 使用大写字母开头的字段名（导出）
   - 使用标签进行元数据标注
   - 考虑使用嵌入实现组合

2. **方法设计**：
   - 值接收者：不修改结构体
   - 指针接收者：需要修改结构体
   - 保持方法集的一致性

3. **构造函数**：
   - 使用 `NewXxx` 命名约定
   - 返回指针类型便于修改

## 下一步

- [接口](./07-接口.md) - 学习接口和多态

