# 模块系统

## 模块系统概述

Node.js 支持两种模块系统：
1. **CommonJS (CJS)** - Node.js 默认的模块系统
2. **ES Modules (ESM)** - JavaScript 标准模块系统

### 与其他语言的对比

| 特性 | Node.js CommonJS | Node.js ESM | Python | Java | Go |
|------|-----------------|-------------|--------|------|-----|
| 加载方式 | 同步 | 异步 | 同步 | 编译时 | 编译时 |
| 导出方式 | module.exports | export | def/class | public class | package |
| 导入方式 | require() | import | import | import | import |
| 循环依赖 | 支持 | 支持 | 支持 | 支持 | 支持 |

## CommonJS 模块

### 导出模块

```javascript
// math.js

// 方式 1：导出单个值
module.exports = function add(a, b) {
  return a + b;
};

// 方式 2：导出对象
module.exports = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b
};

// 方式 3：使用 exports（module.exports 的简写）
exports.add = (a, b) => a + b;
exports.subtract = (a, b) => a - b;

// 注意：不能直接给 exports 赋值
// exports = { add, subtract };  // ❌ 错误
```

### 导入模块

```javascript
// 导入整个模块
const math = require('./math');
console.log(math.add(1, 2));

// 导入特定属性（解构）
const { add, subtract } = require('./math');
console.log(add(1, 2));

// 导入内置模块
const fs = require('fs');
const http = require('http');

// 导入 npm 包
const express = require('express');
const lodash = require('lodash');
```

### 模块缓存

```javascript
// Node.js 会缓存已加载的模块
// 第一次 require 会执行模块代码
const module1 = require('./module');  // 执行模块代码
const module2 = require('./module');  // 返回缓存，不执行

console.log(module1 === module2);  // true

// 清除缓存（不推荐）
delete require.cache[require.resolve('./module')];
const module3 = require('./module');  // 重新执行
```

**与其他语言对比**：
- **Python**: `import module` 或 `from module import function`
- **Java**: `import package.Class` 或 `import static package.Class.method`
- **Go**: `import "package"` 或 `import alias "package"`

## ES Modules (ESM)

### 导出模块

```javascript
// math.mjs 或 package.json 中设置 "type": "module"

// 命名导出
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export const PI = 3.14159;

// 默认导出
export default function multiply(a, b) {
  return a * b;
}

// 或
export { add, subtract };
export default multiply;
```

### 导入模块

```javascript
// 命名导入
import { add, subtract, PI } from './math.js';

// 默认导入
import multiply from './math.js';

// 导入所有
import * as math from './math.js';

// 混合导入
import multiply, { add, subtract } from './math.js';

// 重命名导入
import { add as sum } from './math.js';

// 动态导入
const math = await import('./math.js');
```

### 启用 ESM

```json
// package.json
{
  "type": "module"
}
```

或使用 `.mjs` 扩展名：

```javascript
// math.mjs
export function add(a, b) {
  return a + b;
}
```

**与其他语言对比**：
- **Python**: `from module import function`（类似命名导入）
- **Java**: `import static package.Class.method`（类似命名导入）
- **Go**: `import "package"` 然后使用 `package.Function`

## 模块查找机制

### CommonJS 查找顺序

```javascript
require('./module');  // 相对路径
require('../module'); // 相对路径
require('/absolute/path/module');  // 绝对路径
require('module-name');  // node_modules

// 查找顺序：
// 1. 核心模块（如 fs, http）
// 2. node_modules/module-name
// 3. node_modules/module-name.js
// 4. node_modules/module-name/index.js
// 5. node_modules/module-name/package.json 的 main 字段
```

### ESM 查找顺序

```javascript
// ESM 必须包含文件扩展名
import './module.js';  // ✅ 正确
import './module';      // ❌ 错误（在 ESM 中）

// 查找顺序类似 CommonJS，但必须指定扩展名
```

## 循环依赖

### CommonJS 中的循环依赖

```javascript
// a.js
console.log('a.js 开始执行');
const b = require('./b');
console.log('a.js 中 b =', b);
module.exports = {
  name: 'a',
  b: b
};

// b.js
console.log('b.js 开始执行');
const a = require('./a');
console.log('b.js 中 a =', a);
module.exports = {
  name: 'b',
  a: a
};

// main.js
require('./a');
// 输出：
// a.js 开始执行
// b.js 开始执行
// b.js 中 a = {}  (未完成导出的空对象)
// a.js 中 b = { name: 'b', a: {} }
```

### ESM 中的循环依赖

```javascript
// a.mjs
import { b } from './b.mjs';
export const a = 'a';
console.log('a.mjs:', b);

// b.mjs
import { a } from './a.mjs';
export const b = 'b';
console.log('b.mjs:', a);

// ESM 支持循环依赖，但需要小心使用
```

## 动态导入

### CommonJS 动态导入

```javascript
// 条件导入
if (condition) {
  const module = require('./module');
}

// 动态路径
const moduleName = './module';
const module = require(moduleName);
```

### ESM 动态导入

```javascript
// 使用 import() 函数
async function loadModule() {
  const module = await import('./module.js');
  return module;
}

// 条件导入
if (condition) {
  const module = await import('./module.js');
}

// 动态路径
const moduleName = './module.js';
const module = await import(moduleName);
```

## 模块包装器

### CommonJS 包装

Node.js 会将 CommonJS 模块包装在函数中：

```javascript
// 你的代码
const fs = require('fs');
module.exports = {};

// 实际执行
(function(exports, require, module, __filename, __dirname) {
  const fs = require('fs');
  module.exports = {};
})(module.exports, require, module, __filename, __dirname);
```

### 可用的全局变量

```javascript
// CommonJS 中可用
console.log(__filename);  // 当前文件路径
console.log(__dirname);   // 当前目录路径

// ESM 中需要使用 import.meta
console.log(import.meta.url);  // 当前模块 URL
import { fileURLToPath } from 'url';
import { dirname } from 'path';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

## 实际应用场景

### 场景 1：条件加载模块

```javascript
// 根据环境加载不同模块
let config;

if (process.env.NODE_ENV === 'production') {
  config = require('./config.prod');
} else {
  config = require('./config.dev');
}

// 或使用动态导入（ESM）
async function loadConfig() {
  const env = process.env.NODE_ENV || 'development';
  const config = await import(`./config.${env}.js`);
  return config.default;
}
```

### 场景 2：插件系统

```javascript
// plugin-loader.js
const fs = require('fs');
const path = require('path');

class PluginLoader {
  constructor(pluginDir) {
    this.pluginDir = pluginDir;
    this.plugins = new Map();
  }
  
  loadPlugins() {
    const files = fs.readdirSync(this.pluginDir);
    
    for (const file of files) {
      if (file.endsWith('.js')) {
        try {
          const pluginPath = path.join(this.pluginDir, file);
          const plugin = require(pluginPath);
          
          if (plugin.name && plugin.init) {
            this.plugins.set(plugin.name, plugin);
            console.log(`加载插件: ${plugin.name}`);
          }
        } catch (err) {
          console.error(`加载插件失败 ${file}:`, err);
        }
      }
    }
  }
  
  getPlugin(name) {
    return this.plugins.get(name);
  }
  
  executePlugin(name, ...args) {
    const plugin = this.getPlugin(name);
    if (plugin && plugin.execute) {
      return plugin.execute(...args);
    }
    throw new Error(`插件 ${name} 不存在或没有 execute 方法`);
  }
}

// 使用
const loader = new PluginLoader('./plugins');
loader.loadPlugins();
loader.executePlugin('plugin1', 'arg1', 'arg2');
```

### 场景 3：模块热重载

```javascript
// 开发环境下的模块热重载
function hotReload(modulePath) {
  // 清除缓存
  const resolvedPath = require.resolve(modulePath);
  delete require.cache[resolvedPath];
  
  // 重新加载
  return require(modulePath);
}

// 监听文件变化
const fs = require('fs');
const path = require('path');

function watchModule(modulePath, callback) {
  const resolvedPath = require.resolve(modulePath);
  
  fs.watchFile(resolvedPath, (curr, prev) => {
    if (curr.mtime !== prev.mtime) {
      console.log(`模块 ${modulePath} 已更新，重新加载...`);
      const reloaded = hotReload(modulePath);
      callback(reloaded);
    }
  });
}

// 使用
watchModule('./config', (config) => {
  console.log('配置已更新:', config);
});
```

### 场景 4：模块别名

```javascript
// 使用 module-alias 包
require('module-alias/register');
require('module-alias').addAliases({
  '@': __dirname,
  '@utils': __dirname + '/utils',
  '@models': __dirname + '/models'
});

// 然后可以这样使用
const utils = require('@utils/helper');
const User = require('@models/User');
```

### 场景 5：模块导出适配器

```javascript
// 同时支持 CommonJS 和 ESM
// math.js
function add(a, b) {
  return a + b;
}

// CommonJS 导出
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { add };
}

// ESM 导出
if (typeof window === 'undefined') {
  // Node.js 环境
  if (typeof exports !== 'undefined') {
    exports.add = add;
  }
}
```

## 最佳实践

### 1. 使用明确的文件扩展名

```javascript
// ✅ 推荐：明确指定扩展名
const module = require('./module.js');

// ❌ 不推荐：省略扩展名（虽然可以工作）
const module = require('./module');
```

### 2. 避免循环依赖

```javascript
// ✅ 推荐：使用依赖注入
class ServiceA {
  constructor(serviceB) {
    this.serviceB = serviceB;
  }
}

class ServiceB {
  constructor(serviceA) {
    this.serviceA = serviceA;
  }
}

// ❌ 不推荐：直接循环依赖
// a.js
const b = require('./b');
// b.js
const a = require('./a');
```

### 3. 使用 index.js 作为模块入口

```javascript
// utils/index.js
module.exports = {
  ...require('./string'),
  ...require('./array'),
  ...require('./object')
};

// 使用
const { capitalize, chunk, merge } = require('./utils');
```

### 4. 模块导出单一职责

```javascript
// ✅ 推荐：单一职责
// user-service.js - 用户服务
module.exports = {
  createUser,
  getUser,
  updateUser
};

// ❌ 不推荐：混合职责
// user.js - 包含服务和模型
module.exports = {
  UserModel,
  createUser,
  getUser
};
```

### 5. 使用 ESM 进行现代开发

```json
// package.json
{
  "type": "module",
  "main": "index.js",
  "exports": {
    ".": "./index.js",
    "./utils": "./utils/index.js"
  }
}
```

## CommonJS vs ESM

### 选择建议

- **CommonJS**：
  - 传统 Node.js 项目
  - 需要同步加载
  - 兼容性要求高

- **ESM**：
  - 新项目
  - 需要 Tree Shaking
  - 与前端代码共享
  - 使用现代工具链

### 互操作性

```javascript
// CommonJS 中使用 ESM（有限支持）
import('esm-module.js').then(module => {
  // 使用模块
});

// ESM 中使用 CommonJS
import cjsModule from './cjs-module.js';
// 注意：CommonJS 的默认导出是 module.exports
```

## 总结

- **CommonJS** 是 Node.js 的传统模块系统，使用 `require()` 和 `module.exports`
- **ESM** 是 JavaScript 标准模块系统，使用 `import` 和 `export`
- 模块会被**缓存**，多次 require 同一模块只执行一次
- 注意**循环依赖**的问题，可能导致未完成的导出
- 使用**动态导入**实现条件加载
- 遵循**单一职责**原则组织模块
- 新项目推荐使用 **ESM**，旧项目可以继续使用 CommonJS

