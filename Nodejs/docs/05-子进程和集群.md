# 子进程和集群

## 子进程概述

Node.js 是单线程的，但可以通过 `child_process` 模块创建子进程来执行系统命令、运行其他脚本，或利用多核 CPU。

### 与其他语言的对比

| 特性 | Node.js child_process | Python subprocess | Java ProcessBuilder | Go os/exec |
|------|----------------------|-------------------|---------------------|------------|
| 进程创建 | spawn/exec/fork | subprocess.Popen | ProcessBuilder | exec.Command |
| 通信方式 | stdin/stdout/stderr | pipe | InputStream/OutputStream | io.Pipe |
| 进程池 | cluster 模块 | multiprocessing | ExecutorService | goroutine |
| 共享内存 | 不支持 | multiprocessing | 不支持 | channel |

## 创建子进程

### spawn - 流式执行

`spawn` 适合长时间运行的进程，通过流进行通信。

```javascript
const { spawn } = require('child_process');

// 执行系统命令
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
  console.log(`标准输出: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.error(`标准错误: ${data}`);
});

ls.on('close', (code) => {
  console.log(`子进程退出，退出码: ${code}`);
});

ls.on('error', (err) => {
  console.error('启动失败:', err);
});
```

### exec - 缓冲执行

`exec` 适合短时间运行的命令，一次性返回所有输出。

```javascript
const { exec } = require('child_process');

exec('ls -lh /usr', (error, stdout, stderr) => {
  if (error) {
    console.error(`执行错误: ${error}`);
    return;
  }
  
  if (stderr) {
    console.error(`标准错误: ${stderr}`);
  }
  
  console.log(`标准输出:\n${stdout}`);
});

// 带选项
exec('ls -lh /usr', {
  cwd: '/tmp',           // 工作目录
  env: { ...process.env, CUSTOM_VAR: 'value' },  // 环境变量
  maxBuffer: 1024 * 1024  // 最大缓冲区（默认 1MB）
}, (error, stdout, stderr) => {
  // 处理结果
});
```

### execFile - 执行文件

`execFile` 类似 `exec`，但更安全，不会启动 shell。

```javascript
const { execFile } = require('child_process');

execFile('node', ['--version'], (error, stdout, stderr) => {
  if (error) {
    throw error;
  }
  console.log(`Node.js 版本: ${stdout}`);
});

// 带参数
execFile('git', ['log', '--oneline', '-10'], {
  cwd: '/path/to/repo'
}, (error, stdout, stderr) => {
  if (error) {
    throw error;
  }
  console.log('最近的提交:', stdout);
});
```

### fork - 创建 Node.js 子进程

`fork` 专门用于创建 Node.js 子进程，自动建立 IPC 通信通道。

```javascript
// parent.js
const { fork } = require('child_process');

const child = fork('child.js');

// 发送消息给子进程
child.send({ message: 'Hello from parent' });

// 接收子进程消息
child.on('message', (msg) => {
  console.log('来自子进程:', msg);
});

child.on('exit', (code) => {
  console.log(`子进程退出，退出码: ${code}`);
});

// child.js
process.on('message', (msg) => {
  console.log('来自父进程:', msg);
  
  // 发送消息给父进程
  process.send({ message: 'Hello from child' });
  
  // 退出
  process.exit(0);
});
```

**与其他语言对比**：
- **Python**: `subprocess.Popen()` 或 `multiprocessing.Process()`
- **Java**: `ProcessBuilder` 或 `Runtime.exec()`
- **Go**: `exec.Command()` 或 `os.StartProcess()`

## 进程通信

### 标准输入输出

```javascript
const { spawn } = require('child_process');

// 与子进程交互
const python = spawn('python3', ['-i']);  // 交互式 Python

python.stdout.on('data', (data) => {
  console.log(`Python 输出: ${data}`);
});

python.stdin.write('print("Hello from Node.js")\n');
python.stdin.write('exit()\n');
python.stdin.end();
```

### IPC 通信（fork）

```javascript
// parent.js
const { fork } = require('child_process');

const child = fork('worker.js');

// 发送任务
child.send({ type: 'calculate', data: [1, 2, 3, 4, 5] });

child.on('message', (result) => {
  console.log('计算结果:', result);
  child.kill();
});

// worker.js
process.on('message', (task) => {
  if (task.type === 'calculate') {
    const sum = task.data.reduce((a, b) => a + b, 0);
    process.send({ result: sum });
  }
});
```

### 流式数据处理

```javascript
const { spawn } = require('child_process');
const fs = require('fs');

// 使用管道处理数据
const grep = spawn('grep', ['error'], {
  stdio: ['pipe', 'pipe', 'pipe']
});

const logFile = fs.createReadStream('app.log');
logFile.pipe(grep.stdin);

grep.stdout.on('data', (data) => {
  console.log('匹配的行:', data.toString());
});

grep.on('close', (code) => {
  console.log('grep 完成');
});
```

## 进程池管理

### 简单的进程池

```javascript
const { fork } = require('child_process');

class ProcessPool {
  constructor(script, poolSize = 4) {
    this.script = script;
    this.poolSize = poolSize;
    this.pool = [];
    this.queue = [];
    
    // 初始化进程池
    for (let i = 0; i < poolSize; i++) {
      this.createWorker();
    }
  }
  
  createWorker() {
    const worker = fork(this.script);
    worker.busy = false;
    
    worker.on('message', (result) => {
      worker.busy = false;
      
      // 处理队列中的下一个任务
      if (this.queue.length > 0) {
        const task = this.queue.shift();
        this.assignTask(worker, task);
      }
    });
    
    this.pool.push(worker);
  }
  
  assignTask(worker, task) {
    worker.busy = true;
    worker.send(task);
  }
  
  execute(task) {
    return new Promise((resolve, reject) => {
      // 查找空闲进程
      const idleWorker = this.pool.find(w => !w.busy);
      
      if (idleWorker) {
        idleWorker.once('message', resolve);
        this.assignTask(idleWorker, task);
      } else {
        // 加入队列
        this.queue.push({ task, resolve, reject });
      }
    });
  }
}

// 使用
const pool = new ProcessPool('./worker.js', 4);

(async () => {
  for (let i = 0; i < 10; i++) {
    const result = await pool.execute({ id: i, data: i * 2 });
    console.log('结果:', result);
  }
})();
```

## 集群（Cluster）

### 基本集群

`cluster` 模块允许创建共享服务器端口的子进程，充分利用多核 CPU。

```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`主进程 ${process.pid} 正在运行`);
  
  // 创建工作进程
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 已退出`);
    // 重启工作进程
    console.log('启动新的工作进程');
    cluster.fork();
  });
  
} else {
  // 工作进程共享同一个服务器端口
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`进程 ${process.pid} 处理请求\n`);
  }).listen(3000);
  
  console.log(`工作进程 ${process.pid} 已启动`);
}
```

### 优雅重启

```javascript
const cluster = require('cluster');
const http = require('http');

if (cluster.isMaster) {
  const numWorkers = require('os').cpus().length;
  
  for (let i = 0; i < numWorkers; i++) {
    cluster.fork();
  }
  
  // 监听 SIGUSR2 信号进行零停机重启
  process.on('SIGUSR2', () => {
    console.log('收到重启信号');
    
    const workers = Object.values(cluster.workers);
    
    function restartWorker(index) {
      if (index >= workers.length) return;
      
      const worker = workers[index];
      console.log(`重启工作进程 ${worker.process.pid}`);
      
      const newWorker = cluster.fork();
      
      newWorker.on('listening', () => {
        worker.kill();
        restartWorker(index + 1);
      });
    }
    
    restartWorker(0);
  });
  
} else {
  const server = http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`进程 ${process.pid} 响应\n`);
  });
  
  server.listen(3000);
}
```

**与其他语言对比**：
- **Python**: `multiprocessing` 或 `gunicorn` 等 WSGI 服务器
- **Java**: 应用服务器（如 Tomcat）的集群功能
- **Go**: 使用 goroutine 或第三方负载均衡器

## Worker Threads

Worker Threads 用于 CPU 密集型任务，与子进程不同，它们共享内存。

### 基本用法

```javascript
// main.js
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

if (isMainThread) {
  // 主线程
  const worker = new Worker(__filename, {
    workerData: { start: 0, end: 10000000 }
  });
  
  worker.on('message', (result) => {
    console.log('计算结果:', result);
  });
  
  worker.on('error', (err) => {
    console.error('Worker 错误:', err);
  });
  
  worker.on('exit', (code) => {
    if (code !== 0) {
      console.error(`Worker 退出，退出码: ${code}`);
    }
  });
} else {
  // Worker 线程
  const { start, end } = workerData;
  let sum = 0;
  
  for (let i = start; i < end; i++) {
    sum += i;
  }
  
  parentPort.postMessage(sum);
}
```

### 共享内存（SharedArrayBuffer）

```javascript
const { Worker, isMainThread, parentPort } = require('worker_threads');

if (isMainThread) {
  // 创建共享内存
  const sharedBuffer = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 10);
  const sharedArray = new Int32Array(sharedBuffer);
  
  // 创建多个 Worker
  const numWorkers = 4;
  const workers = [];
  
  for (let i = 0; i < numWorkers; i++) {
    const worker = new Worker(__filename, {
      workerData: { sharedArray, workerId: i }
    });
    workers.push(worker);
  }
  
  // 等待所有 Worker 完成
  Promise.all(workers.map(w => new Promise(resolve => w.on('exit', resolve))))
    .then(() => {
      console.log('共享数组:', Array.from(sharedArray));
    });
    
} else {
  const { sharedArray, workerId } = require('worker_threads').workerData;
  
  // 在共享内存中写入数据
  Atomics.add(sharedArray, workerId, workerId * 10);
  
  parentPort.postMessage('完成');
}
```

## 实际应用场景

### 场景 1：并行处理任务

```javascript
const { fork } = require('child_process');

async function processTasksInParallel(tasks, concurrency = 4) {
  const results = [];
  const workers = [];
  let taskIndex = 0;
  
  // 创建工作进程
  for (let i = 0; i < concurrency; i++) {
    const worker = fork('task-worker.js');
    workers.push(worker);
    
    worker.on('message', (result) => {
      results.push(result);
      
      // 分配下一个任务
      if (taskIndex < tasks.length) {
        worker.send(tasks[taskIndex++]);
      } else {
        worker.kill();
      }
    });
    
    // 分配初始任务
    if (taskIndex < tasks.length) {
      worker.send(tasks[taskIndex++]);
    }
  }
  
  // 等待所有任务完成
  return new Promise((resolve) => {
    let completed = 0;
    workers.forEach(worker => {
      worker.on('exit', () => {
        completed++;
        if (completed === workers.length) {
          resolve(results);
        }
      });
    });
  });
}

// 使用
(async () => {
  const tasks = Array.from({ length: 100 }, (_, i) => ({ id: i }));
  const results = await processTasksInParallel(tasks, 4);
  console.log('处理完成，结果数量:', results.length);
})();
```

### 场景 2：CPU 密集型计算

```javascript
// main.js
const { Worker } = require('worker_threads');
const os = require('os');

function calculateWithWorkers(data, numWorkers = os.cpus().length) {
  return new Promise((resolve, reject) => {
    const chunkSize = Math.ceil(data.length / numWorkers);
    const workers = [];
    const results = [];
    let completed = 0;
    
    for (let i = 0; i < numWorkers; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, data.length);
      const chunk = data.slice(start, end);
      
      const worker = new Worker('./compute-worker.js', {
        workerData: { data: chunk, index: i }
      });
      
      worker.on('message', (result) => {
        results[result.index] = result.value;
        completed++;
        
        if (completed === numWorkers) {
          resolve(results.reduce((a, b) => a + b, 0));
        }
      });
      
      worker.on('error', reject);
      workers.push(worker);
    }
  });
}

// compute-worker.js
const { workerData, parentPort } = require('worker_threads');

const { data, index } = workerData;

// CPU 密集型计算
let result = 0;
for (const value of data) {
  result += Math.sqrt(value) * Math.sin(value);
}

parentPort.postMessage({ index, value: result });
```

### 场景 3：负载均衡服务器

```javascript
const cluster = require('cluster');
const http = require('http');
const os = require('os');

if (cluster.isMaster) {
  const numWorkers = os.cpus().length;
  console.log(`启动 ${numWorkers} 个工作进程`);
  
  // 创建工作进程
  for (let i = 0; i < numWorkers; i++) {
    const worker = cluster.fork();
    console.log(`工作进程 ${worker.process.pid} 已启动`);
  }
  
  // 监控工作进程
  cluster.on('online', (worker) => {
    console.log(`工作进程 ${worker.process.pid} 在线`);
  });
  
  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 退出`);
    console.log('启动新的工作进程');
    cluster.fork();
  });
  
} else {
  // 工作进程代码
  const server = http.createServer((req, res) => {
    // 模拟处理时间
    const start = Date.now();
    
    // 处理请求
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      pid: process.pid,
      uptime: process.uptime(),
      memory: process.memoryUsage()
    }));
    
    const duration = Date.now() - start;
    console.log(`进程 ${process.pid} 处理请求，耗时 ${duration}ms`);
  });
  
  server.listen(3000, () => {
    console.log(`工作进程 ${process.pid} 监听端口 3000`);
  });
}
```

## 最佳实践

### 1. 进程生命周期管理

```javascript
const { spawn } = require('child_process');

class ManagedProcess {
  constructor(command, args) {
    this.process = spawn(command, args);
    this.process.on('exit', this.onExit.bind(this));
  }
  
  onExit(code) {
    console.log(`进程退出，退出码: ${code}`);
    // 清理资源
  }
  
  kill(signal = 'SIGTERM') {
    this.process.kill(signal);
  }
  
  restart() {
    this.kill();
    // 重新启动逻辑
  }
}
```

### 2. 超时控制

```javascript
const { spawn } = require('child_process');

function spawnWithTimeout(command, args, timeout = 5000) {
  const child = spawn(command, args);
  let finished = false;
  
  const timer = setTimeout(() => {
    if (!finished) {
      finished = true;
      child.kill('SIGTERM');
      console.error('进程超时');
    }
  }, timeout);
  
  child.on('exit', () => {
    if (!finished) {
      finished = true;
      clearTimeout(timer);
    }
  });
  
  return child;
}
```

### 3. 资源限制

```javascript
const { spawn } = require('child_process');

const child = spawn('node', ['script.js'], {
  // 设置资源限制（需要系统支持）
  // maxBuffer: 1024 * 1024,
  // stdio: 'inherit'
});

// 监控资源使用
setInterval(() => {
  const usage = process.memoryUsage();
  console.log('内存使用:', usage);
}, 1000);
```

## 总结

- **child_process** 用于创建系统进程，适合 I/O 密集型任务
- **cluster** 用于创建 Node.js 进程集群，充分利用多核 CPU
- **worker_threads** 用于 CPU 密集型任务，共享内存
- 使用 **fork** 进行 Node.js 进程间通信
- 使用 **spawn** 执行系统命令和长时间运行的进程
- 实现**进程池**管理多个子进程
- 正确处理**进程生命周期**和**错误处理**

