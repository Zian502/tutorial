# 错误处理

## 错误类型

### JavaScript 错误类型

```javascript
// Error - 基础错误类型
throw new Error('基础错误');

// TypeError - 类型错误
throw new TypeError('类型错误');

// ReferenceError - 引用错误
throw new ReferenceError('引用错误');

// SyntaxError - 语法错误
throw new SyntaxError('语法错误');

// RangeError - 范围错误
throw new RangeError('范围错误');

// 自定义错误
class CustomError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'CustomError';
    this.code = code;
  }
}

throw new CustomError('自定义错误', 'CUSTOM_001');
```

### Node.js 特定错误

```javascript
// SystemError - 系统错误
const fs = require('fs');
fs.readFile('nonexistent.txt', (err) => {
  if (err) {
    console.log(err instanceof Error);  // true
    console.log(err.code);  // 'ENOENT'
    console.log(err.syscall);  // 'open'
    console.log(err.path);  // 'nonexistent.txt'
  }
});
```

**与其他语言对比**：
- **Python**: `Exception`, `ValueError`, `TypeError`, `FileNotFoundError`
- **Java**: `Exception`, `RuntimeException`, `IOException`
- **Go**: `error` 接口，返回错误值

## 错误处理模式

### 1. 回调错误处理

```javascript
const fs = require('fs');

// 错误优先回调（Error-First Callback）
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    // 处理错误
    console.error('读取失败:', err);
    return;
  }
  
  // 处理数据
  console.log('文件内容:', data);
});

// 封装为 Promise
function readFilePromise(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}
```

### 2. Promise 错误处理

```javascript
// 使用 .catch()
readFilePromise('file.txt')
  .then(data => {
    console.log('文件内容:', data);
  })
  .catch(err => {
    console.error('读取失败:', err);
  });

// 使用 try/catch 和 async/await
async function readFile() {
  try {
    const data = await readFilePromise('file.txt');
    console.log('文件内容:', data);
  } catch (err) {
    console.error('读取失败:', err);
  }
}
```

### 3. 错误传播

```javascript
// Promise 链中的错误传播
function step1() {
  return Promise.reject(new Error('步骤1失败'));
}

function step2() {
  return Promise.resolve('步骤2成功');
}

step1()
  .then(() => step2())
  .then(result => console.log(result))
  .catch(err => {
    // 捕获所有步骤的错误
    console.error('错误:', err.message);
  });

// async/await 中的错误传播
async function processSteps() {
  try {
    await step1();
    await step2();
  } catch (err) {
    // 捕获任何步骤的错误
    console.error('错误:', err.message);
  }
}
```

## 全局错误处理

### 未捕获的异常

```javascript
// 捕获未处理的异常
process.on('uncaughtException', (err) => {
  console.error('未捕获的异常:', err);
  // 记录错误
  // 清理资源
  process.exit(1);  // 退出进程
});

// 示例
throw new Error('未捕获的错误');
```

### 未处理的 Promise 拒绝

```javascript
// 捕获未处理的 Promise 拒绝
process.on('unhandledRejection', (reason, promise) => {
  console.error('未处理的 Promise 拒绝:', reason);
  // 记录错误
  process.exit(1);
});

// 示例
Promise.reject(new Error('未处理的拒绝'));

// 或使用警告（不退出）
process.on('unhandledRejection', (reason, promise) => {
  console.warn('未处理的 Promise 拒绝:', reason);
});
```

### 警告处理

```javascript
// 捕获警告
process.on('warning', (warning) => {
  console.warn('警告:', warning.name);
  console.warn('消息:', warning.message);
  console.warn('堆栈:', warning.stack);
});

// 触发警告
process.emitWarning('这是一个警告', 'CustomWarning');
```

## 错误处理最佳实践

### 1. 创建自定义错误类

```javascript
class AppError extends Error {
  constructor(message, statusCode, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.name = this.constructor.name;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

class ValidationError extends AppError {
  constructor(message) {
    super(message, 400);
  }
}

class NotFoundError extends AppError {
  constructor(resource) {
    super(`${resource} 未找到`, 404);
  }
}

class DatabaseError extends AppError {
  constructor(message) {
    super(message, 500, false);  // 非操作错误
  }
}

// 使用
function getUser(id) {
  if (!id) {
    throw new ValidationError('用户 ID 不能为空');
  }
  
  const user = db.findUser(id);
  if (!user) {
    throw new NotFoundError('用户');
  }
  
  return user;
}
```

### 2. 错误分类

```javascript
// 操作错误 vs 编程错误
function handleError(err, req, res, next) {
  // 操作错误：可预期的错误
  if (err.isOperational) {
    res.status(err.statusCode || 500).json({
      error: {
        message: err.message,
        code: err.code
      }
    });
  } else {
    // 编程错误：记录但不暴露细节
    console.error('编程错误:', err);
    res.status(500).json({
      error: {
        message: '服务器内部错误'
      }
    });
  }
}
```

### 3. 错误日志记录

```javascript
const fs = require('fs').promises;
const path = require('path');

class ErrorLogger {
  constructor(logDir = './logs') {
    this.logDir = logDir;
  }
  
  async init() {
    await fs.mkdir(this.logDir, { recursive: true });
  }
  
  async logError(err, context = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      error: {
        name: err.name,
        message: err.message,
        stack: err.stack,
        code: err.code
      },
      context
    };
    
    const logFile = path.join(
      this.logDir,
      `error-${new Date().toISOString().split('T')[0]}.log`
    );
    
    await fs.appendFile(
      logFile,
      JSON.stringify(logEntry) + '\n',
      'utf8'
    );
  }
}

// 使用
const logger = new ErrorLogger();
await logger.init();

try {
  // 可能出错的代码
} catch (err) {
  await logger.logError(err, {
    userId: req.user?.id,
    url: req.url,
    method: req.method
  });
  throw err;
}
```

### 4. 错误恢复

```javascript
// 重试机制
async function retryOperation(operation, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (err) {
      if (i === maxRetries - 1) {
        throw err;
      }
      
      console.log(`重试 ${i + 1}/${maxRetries}...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// 使用
async function fetchData() {
  return await retryOperation(
    () => fetch('https://api.example.com/data'),
    3,
    1000
  );
}
```

### 5. 错误边界

```javascript
// 包装异步函数，自动处理错误
function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next))
      .catch(next);
  };
}

// 使用
app.get('/users/:id', asyncHandler(async (req, res) => {
  const user = await getUser(req.params.id);
  res.json(user);
}));

// 或使用 Express 的错误处理中间件
app.use((err, req, res, next) => {
  console.error('错误:', err);
  res.status(err.statusCode || 500).json({
    error: err.message
  });
});
```

## 实际应用场景

### 场景 1：API 错误处理

```javascript
const http = require('http');

class APIError extends Error {
  constructor(message, statusCode, code) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.name = 'APIError';
  }
}

class ValidationError extends APIError {
  constructor(message) {
    super(message, 400, 'VALIDATION_ERROR');
  }
}

class NotFoundError extends APIError {
  constructor(resource) {
    super(`${resource} 未找到`, 404, 'NOT_FOUND');
  }
}

const server = http.createServer(async (req, res) => {
  try {
    // 处理请求
    if (req.url === '/users/123') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ id: 123, name: 'Alice' }));
    } else {
      throw new NotFoundError('用户');
    }
  } catch (err) {
    if (err instanceof APIError) {
      res.writeHead(err.statusCode, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        error: {
          message: err.message,
          code: err.code
        }
      }));
    } else {
      // 未知错误
      console.error('未知错误:', err);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        error: {
          message: '服务器内部错误',
          code: 'INTERNAL_ERROR'
        }
      }));
    }
  }
});

server.listen(3000);
```

### 场景 2：数据库错误处理

```javascript
class DatabaseError extends Error {
  constructor(message, originalError) {
    super(message);
    this.name = 'DatabaseError';
    this.originalError = originalError;
    this.code = originalError?.code;
  }
}

async function queryDatabase(query, params) {
  try {
    // 执行数据库查询
    return await db.query(query, params);
  } catch (err) {
    // 分类数据库错误
    if (err.code === 'ECONNREFUSED') {
      throw new DatabaseError('数据库连接失败', err);
    } else if (err.code === 'ER_DUP_ENTRY') {
      throw new DatabaseError('重复的条目', err);
    } else {
      throw new DatabaseError('数据库查询失败', err);
    }
  }
}

// 使用
try {
  const result = await queryDatabase('SELECT * FROM users WHERE id = ?', [123]);
} catch (err) {
  if (err instanceof DatabaseError) {
    console.error('数据库错误:', err.message);
    // 处理数据库错误
  } else {
    throw err;
  }
}
```

### 场景 3：文件操作错误处理

```javascript
const fs = require('fs').promises;

async function safeFileOperation(filePath, operation) {
  try {
    return await operation(filePath);
  } catch (err) {
    // 分类文件错误
    if (err.code === 'ENOENT') {
      throw new Error(`文件不存在: ${filePath}`);
    } else if (err.code === 'EACCES') {
      throw new Error(`权限不足: ${filePath}`);
    } else if (err.code === 'EMFILE') {
      throw new Error('打开的文件过多');
    } else {
      throw new Error(`文件操作失败: ${err.message}`);
    }
  }
}

// 使用
try {
  const data = await safeFileOperation('file.txt', async (path) => {
    return await fs.readFile(path, 'utf8');
  });
} catch (err) {
  console.error('文件操作错误:', err.message);
}
```

### 场景 4：网络请求错误处理

```javascript
const https = require('https');

class NetworkError extends Error {
  constructor(message, statusCode, originalError) {
    super(message);
    this.name = 'NetworkError';
    this.statusCode = statusCode;
    this.originalError = originalError;
  }
}

function httpRequest(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      let data = '';
      
      res.on('data', chunk => {
        data += chunk.toString();
      });
      
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data);
        } else {
          reject(new NetworkError(
            `HTTP ${res.statusCode}`,
            res.statusCode
          ));
        }
      });
    }).on('error', (err) => {
      reject(new NetworkError('网络请求失败', null, err));
    });
  });
}

// 使用
async function fetchData() {
  try {
    const data = await httpRequest('https://api.example.com/data');
    return JSON.parse(data);
  } catch (err) {
    if (err instanceof NetworkError) {
      if (err.statusCode === 404) {
        console.error('资源未找到');
      } else if (err.statusCode >= 500) {
        console.error('服务器错误');
      } else {
        console.error('网络错误:', err.message);
      }
    } else {
      throw err;
    }
  }
}
```

### 场景 5：错误监控和报告

```javascript
class ErrorMonitor {
  constructor() {
    this.errors = [];
    this.maxErrors = 100;
  }
  
  recordError(err, context = {}) {
    const errorRecord = {
      timestamp: Date.now(),
      error: {
        name: err.name,
        message: err.message,
        stack: err.stack
      },
      context
    };
    
    this.errors.push(errorRecord);
    
    // 限制错误数量
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
    
    // 发送到监控服务（如 Sentry）
    this.reportError(errorRecord);
  }
  
  reportError(errorRecord) {
    // 发送到外部监控服务
    console.log('报告错误:', errorRecord);
    // fetch('https://sentry.io/api/errors', {
    //   method: 'POST',
    //   body: JSON.stringify(errorRecord)
    // });
  }
  
  getErrors() {
    return this.errors;
  }
}

// 使用
const monitor = new ErrorMonitor();

process.on('uncaughtException', (err) => {
  monitor.recordError(err, {
    type: 'uncaughtException'
  });
  process.exit(1);
});

process.on('unhandledRejection', (reason) => {
  monitor.recordError(reason, {
    type: 'unhandledRejection'
  });
});
```

## 最佳实践

### 1. 始终处理错误

```javascript
// ✅ 正确：处理所有可能的错误
async function processData() {
  try {
    const data = await fetchData();
    return process(data);
  } catch (err) {
    console.error('处理失败:', err);
    throw err;  // 或返回默认值
  }
}

// ❌ 错误：忽略错误
async function processDataBad() {
  const data = await fetchData();  // 可能抛出错误
  return process(data);
}
```

### 2. 提供有意义的错误消息

```javascript
// ✅ 正确：清晰的错误消息
if (!userId) {
  throw new ValidationError('用户 ID 不能为空');
}

// ❌ 错误：模糊的错误消息
if (!userId) {
  throw new Error('错误');
}
```

### 3. 不要吞掉错误

```javascript
// ✅ 正确：记录或重新抛出错误
try {
  await operation();
} catch (err) {
  console.error('操作失败:', err);
  throw err;  // 或处理错误
}

// ❌ 错误：静默忽略错误
try {
  await operation();
} catch (err) {
  // 什么都不做
}
```

### 4. 使用错误代码

```javascript
class AppError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}

// 使用错误代码进行分类
const errors = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  UNAUTHORIZED: 'UNAUTHORIZED'
};

throw new AppError('用户未找到', errors.NOT_FOUND);
```

## 总结

- 使用**自定义错误类**提供更好的错误信息
- 区分**操作错误**和**编程错误**
- 始终**处理错误**，不要忽略
- 使用**错误日志**记录错误信息
- 实现**错误恢复**机制（如重试）
- 设置**全局错误处理**捕获未处理的异常
- 提供**有意义的错误消息**和**错误代码**
- 在 API 中返回**结构化的错误响应**

