# 性能优化和调试

## 性能分析工具

### console.time 和 console.timeEnd

```javascript
// 测量代码执行时间
console.time('操作耗时');

// 执行一些操作
for (let i = 0; i < 1000000; i++) {
  Math.sqrt(i);
}

console.timeEnd('操作耗时');
// 输出：操作耗时: 45.123ms
```

### process.hrtime 和 process.hrtime.bigint

```javascript
// 高精度时间测量
const start = process.hrtime.bigint();

// 执行操作
for (let i = 0; i < 1000000; i++) {
  Math.sqrt(i);
}

const end = process.hrtime.bigint();
const duration = Number(end - start) / 1000000;  // 转换为毫秒
console.log(`耗时: ${duration.toFixed(2)}ms`);
```

### process.memoryUsage

```javascript
// 监控内存使用
function logMemoryUsage() {
  const usage = process.memoryUsage();
  console.log({
    rss: `${Math.round(usage.rss / 1024 / 1024 * 100) / 100} MB`,  // 常驻集大小
    heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024 * 100) / 100} MB`,
    heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024 * 100) / 100} MB`,
    external: `${Math.round(usage.external / 1024 / 1024 * 100) / 100} MB`
  });
}

logMemoryUsage();

// 执行一些操作后再次检查
setTimeout(() => {
  logMemoryUsage();
}, 5000);
```

## 性能分析器

### 使用 --prof 标志

```bash
# 运行应用并生成性能分析文件
node --prof app.js

# 处理分析文件
node --prof-process isolate-*.log > processed.txt
```

### 使用 --inspect 和 Chrome DevTools

```bash
# 启动调试模式
node --inspect app.js

# 或指定端口
node --inspect=9229 app.js
```

然后在 Chrome 浏览器中打开 `chrome://inspect`，点击 "inspect" 连接。

### 使用 clinic.js

```bash
# 安装
npm install -g clinic

# 性能分析
clinic doctor -- node app.js

# 火焰图
clinic flame -- node app.js

# 气泡图
clinic bubbleprof -- node app.js
```

## 性能优化技巧

### 1. 避免阻塞事件循环

```javascript
// ❌ 不好：阻塞事件循环
function heavyComputation() {
  let sum = 0;
  for (let i = 0; i < 10000000000; i++) {
    sum += i;
  }
  return sum;
}

// ✅ 好：使用 setImmediate 分片处理
function heavyComputationAsync(data, callback) {
  let sum = 0;
  let index = 0;
  
  function processChunk() {
    const chunkSize = 1000000;
    const end = Math.min(index + chunkSize, data.length);
    
    for (let i = index; i < end; i++) {
      sum += data[i];
    }
    
    index = end;
    
    if (index < data.length) {
      setImmediate(processChunk);  // 让出事件循环
    } else {
      callback(sum);
    }
  }
  
  processChunk();
}

// ✅ 更好：使用 Worker Threads
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

if (isMainThread) {
  function heavyComputationWithWorker(data) {
    return new Promise((resolve, reject) => {
      const worker = new Worker(__filename, {
        workerData: { data }
      });
      
      worker.on('message', resolve);
      worker.on('error', reject);
    });
  }
} else {
  const { data } = workerData;
  let sum = 0;
  for (const value of data) {
    sum += value;
  }
  parentPort.postMessage(sum);
}
```

### 2. 优化异步操作

```javascript
// ❌ 不好：顺序执行
async function fetchSequential() {
  const result1 = await fetch('url1');
  const result2 = await fetch('url2');
  const result3 = await fetch('url3');
  return [result1, result2, result3];
}

// ✅ 好：并行执行
async function fetchParallel() {
  const [result1, result2, result3] = await Promise.all([
    fetch('url1'),
    fetch('url2'),
    fetch('url3')
  ]);
  return [result1, result2, result3];
}
```

### 3. 使用流处理大文件

```javascript
// ❌ 不好：一次性读取大文件
const fs = require('fs').promises;

async function processLargeFileBad(filePath) {
  const data = await fs.readFile(filePath);  // 可能内存溢出
  // 处理数据
}

// ✅ 好：使用流
const fs = require('fs');

function processLargeFile(filePath) {
  return new Promise((resolve, reject) => {
    const stream = fs.createReadStream(filePath);
    let processed = 0;
    
    stream.on('data', (chunk) => {
      // 处理数据块
      processed += chunk.length;
    });
    
    stream.on('end', () => {
      resolve(processed);
    });
    
    stream.on('error', reject);
  });
}
```

### 4. 对象池模式

```javascript
// 对象池：重用对象，减少 GC 压力
class ObjectPool {
  constructor(createFn, resetFn, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
    
    // 预创建对象
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(createFn());
    }
  }
  
  acquire() {
    return this.pool.pop() || this.createFn();
  }
  
  release(obj) {
    if (this.resetFn) {
      this.resetFn(obj);
    }
    this.pool.push(obj);
  }
}

// 使用
const bufferPool = new ObjectPool(
  () => Buffer.alloc(1024),
  (buf) => buf.fill(0)
);

const buf = bufferPool.acquire();
// 使用缓冲区
bufferPool.release(buf);
```

### 5. 缓存优化

```javascript
// 简单的内存缓存
class SimpleCache {
  constructor(ttl = 60000) {  // 默认 1 分钟
    this.cache = new Map();
    this.ttl = ttl;
  }
  
  set(key, value) {
    this.cache.set(key, {
      value,
      expires: Date.now() + this.ttl
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) {
      return null;
    }
    
    if (Date.now() > item.expires) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  clear() {
    this.cache.clear();
  }
}

// 使用
const cache = new SimpleCache(60000);

function expensiveOperation(input) {
  const cached = cache.get(input);
  if (cached) {
    return cached;
  }
  
  // 执行昂贵操作
  const result = /* ... */;
  cache.set(input, result);
  return result;
}
```

## 调试技巧

### 使用 console 调试

```javascript
// console.log 的替代方案
console.log('普通日志');
console.error('错误日志');
console.warn('警告日志');
console.info('信息日志');
console.debug('调试日志');

// 格式化输出
console.log('用户: %s, 年龄: %d', 'Alice', 25);
console.log('对象:', { name: 'Alice', age: 25 });

// 表格输出
console.table([
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 }
]);

// 堆栈跟踪
console.trace('调用堆栈');
```

### 使用 debugger 语句

```javascript
function complexFunction(data) {
  debugger;  // 设置断点
  
  // 代码执行会在这里暂停（如果使用 --inspect）
  const result = processData(data);
  return result;
}
```

### 使用 Node.js 内置调试器

```bash
# 启动调试模式
node inspect app.js

# 调试命令
# n - 下一行
# s - 进入函数
# o - 跳出函数
# c - 继续执行
# repl - 进入 REPL 模式
```

### 使用第三方调试工具

```javascript
// 使用 debug 模块
const debug = require('debug')('app:server');

debug('服务器启动');
debug('处理请求: %s', req.url);

// 设置环境变量启用调试
// DEBUG=app:* node app.js
```

## 内存泄漏检测

### 使用 heapdump

```javascript
const heapdump = require('heapdump');

// 生成堆快照
function takeHeapSnapshot() {
  const filename = `heap-${Date.now()}.heapsnapshot`;
  heapdump.writeSnapshot(filename, (err) => {
    if (err) {
      console.error('生成堆快照失败:', err);
    } else {
      console.log('堆快照已保存:', filename);
    }
  });
}

// 定期生成快照
setInterval(takeHeapSnapshot, 60000);  // 每分钟
```

### 监控内存使用

```javascript
class MemoryMonitor {
  constructor(threshold = 100 * 1024 * 1024) {  // 100MB
    this.threshold = threshold;
    this.interval = null;
  }
  
  start() {
    this.interval = setInterval(() => {
      const usage = process.memoryUsage();
      
      if (usage.heapUsed > this.threshold) {
        console.warn('内存使用超过阈值:', {
          heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)} MB`,
          threshold: `${Math.round(this.threshold / 1024 / 1024)} MB`
        });
      }
    }, 5000);
  }
  
  stop() {
    if (this.interval) {
      clearInterval(this.interval);
    }
  }
}

// 使用
const monitor = new MemoryMonitor(100 * 1024 * 1024);
monitor.start();
```

## 实际应用场景

### 场景 1：API 性能监控

```javascript
const http = require('http');

class APIMonitor {
  constructor() {
    this.metrics = {
      requests: 0,
      errors: 0,
      totalTime: 0,
      minTime: Infinity,
      maxTime: 0
    };
  }
  
  middleware() {
    return (req, res, next) => {
      const start = Date.now();
      this.metrics.requests++;
      
      res.on('finish', () => {
        const duration = Date.now() - start;
        this.metrics.totalTime += duration;
        this.metrics.minTime = Math.min(this.metrics.minTime, duration);
        this.metrics.maxTime = Math.max(this.metrics.maxTime, duration);
        
        if (res.statusCode >= 400) {
          this.metrics.errors++;
        }
      });
      
      next();
    };
  }
  
  getStats() {
    return {
      ...this.metrics,
      avgTime: this.metrics.requests > 0
        ? this.metrics.totalTime / this.metrics.requests
        : 0
    };
  }
}

// 使用
const monitor = new APIMonitor();
const server = http.createServer((req, res) => {
  monitor.middleware()(req, res, () => {
    // 处理请求
    res.end('OK');
  });
});

// 定期输出统计
setInterval(() => {
  console.log('API 统计:', monitor.getStats());
}, 10000);
```

### 场景 2：数据库查询优化

```javascript
class QueryOptimizer {
  constructor() {
    this.queryCache = new Map();
    this.slowQueryThreshold = 1000;  // 1秒
  }
  
  async execute(query, params) {
    const start = Date.now();
    const cacheKey = `${query}:${JSON.stringify(params)}`;
    
    // 检查缓存
    const cached = this.queryCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < 60000) {
      return cached.result;
    }
    
    try {
      // 执行查询
      const result = await this.runQuery(query, params);
      const duration = Date.now() - start;
      
      // 记录慢查询
      if (duration > this.slowQueryThreshold) {
        console.warn('慢查询:', {
          query,
          duration,
          params
        });
      }
      
      // 缓存结果
      this.queryCache.set(cacheKey, {
        result,
        timestamp: Date.now()
      });
      
      return result;
    } catch (err) {
      console.error('查询错误:', err);
      throw err;
    }
  }
  
  async runQuery(query, params) {
    // 实际的数据库查询
    return [];
  }
}
```

### 场景 3：请求限流

```javascript
class RateLimiter {
  constructor(maxRequests, windowMs) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = new Map();
  }
  
  isAllowed(identifier) {
    const now = Date.now();
    const userRequests = this.requests.get(identifier) || [];
    
    // 清理过期请求
    const validRequests = userRequests.filter(
      timestamp => now - timestamp < this.windowMs
    );
    
    if (validRequests.length >= this.maxRequests) {
      return false;
    }
    
    validRequests.push(now);
    this.requests.set(identifier, validRequests);
    return true;
  }
  
  reset() {
    this.requests.clear();
  }
}

// 使用
const limiter = new RateLimiter(100, 60000);  // 每分钟 100 次

const server = http.createServer((req, res) => {
  const clientId = req.headers['x-client-id'] || req.socket.remoteAddress;
  
  if (!limiter.isAllowed(clientId)) {
    res.statusCode = 429;
    res.end('请求过多');
    return;
  }
  
  // 处理请求
  res.end('OK');
});
```

## 性能测试

### 基准测试

```javascript
function benchmark(name, fn, iterations = 1000) {
  const times = [];
  
  // 预热
  for (let i = 0; i < 10; i++) {
    fn();
  }
  
  // 测试
  for (let i = 0; i < iterations; i++) {
    const start = process.hrtime.bigint();
    fn();
    const end = process.hrtime.bigint();
    times.push(Number(end - start) / 1000000);  // 转换为毫秒
  }
  
  const avg = times.reduce((a, b) => a + b, 0) / times.length;
  const min = Math.min(...times);
  const max = Math.max(...times);
  
  console.log(`${name}:`);
  console.log(`  平均: ${avg.toFixed(2)}ms`);
  console.log(`  最小: ${min.toFixed(2)}ms`);
  console.log(`  最大: ${max.toFixed(2)}ms`);
}

// 使用
benchmark('数组操作', () => {
  const arr = Array.from({ length: 1000 }, (_, i) => i);
  return arr.map(x => x * 2).filter(x => x > 100);
});
```

## 最佳实践

### 1. 定期性能分析

```javascript
// 定期输出性能指标
setInterval(() => {
  const usage = process.memoryUsage();
  const uptime = process.uptime();
  
  console.log({
    uptime: `${Math.round(uptime)}s`,
    memory: {
      heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)} MB`,
      heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)} MB`,
      rss: `${Math.round(usage.rss / 1024 / 1024)} MB`
    }
  });
}, 30000);  // 每 30 秒
```

### 2. 使用性能监控工具

```javascript
// 集成 APM 工具（如 New Relic, DataDog）
const newrelic = require('newrelic');

// 自动监控
app.use(newrelic.expressMiddleware());
```

### 3. 代码分析

```bash
# 使用 ESLint 检查代码质量
npm install -g eslint
eslint app.js

# 使用 JSHint
npm install -g jshint
jshint app.js
```

## 总结

- 使用 **性能分析工具**（--inspect, clinic.js）识别瓶颈
- 避免**阻塞事件循环**，使用 Worker Threads 处理 CPU 密集型任务
- **并行执行**异步操作，使用 Promise.all
- 使用**流**处理大文件，避免内存溢出
- 实现**缓存**和**对象池**减少 GC 压力
- 监控**内存使用**，检测内存泄漏
- 使用 **debugger** 和调试工具进行问题排查
- 定期进行**性能测试**和**基准测试**

