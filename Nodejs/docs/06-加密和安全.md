# 加密和安全

## crypto 模块概述

Node.js 的 `crypto` 模块提供了加密功能，包括哈希、HMAC、加密解密、数字签名等。

### 与其他语言的对比

| 特性 | Node.js crypto | Python hashlib/cryptography | Java java.security | Go crypto |
|------|----------------|----------------------------|-------------------|----------|
| 哈希算法 | 支持多种 | 支持多种 | 支持多种 | 支持多种 |
| 对称加密 | AES/DES | AES/DES | AES/DES | AES/DES |
| 非对称加密 | RSA/ECDSA | RSA/ECDSA | RSA/ECDSA | RSA/ECDSA |
| 数字签名 | 支持 | 支持 | 支持 | 支持 |

## 哈希（Hash）

### 基本哈希

```javascript
const crypto = require('crypto');

// 创建哈希对象
const hash = crypto.createHash('sha256');
hash.update('Hello, Node.js!');
const digest = hash.digest('hex');

console.log('SHA256 哈希值:', digest);

// 一次性计算
const hash2 = crypto.createHash('md5')
  .update('Hello, Node.js!')
  .digest('hex');

console.log('MD5 哈希值:', hash2);
```

### 支持的哈希算法

```javascript
const crypto = require('crypto');

const algorithms = ['md5', 'sha1', 'sha256', 'sha512', 'sha3-256'];

function hashData(data, algorithm) {
  return crypto.createHash(algorithm)
    .update(data)
    .digest('hex');
}

const data = 'Hello, Node.js!';
algorithms.forEach(algo => {
  console.log(`${algo}:`, hashData(data, algo));
});
```

### 流式哈希

```javascript
const crypto = require('crypto');
const fs = require('fs');

// 计算文件哈希
function hashFile(filePath) {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash('sha256');
    const stream = fs.createReadStream(filePath);
    
    stream.on('data', (chunk) => {
      hash.update(chunk);
    });
    
    stream.on('end', () => {
      resolve(hash.digest('hex'));
    });
    
    stream.on('error', reject);
  });
}

// 使用
hashFile('large-file.txt')
  .then(hash => {
    console.log('文件哈希值:', hash);
  })
  .catch(err => {
    console.error('计算失败:', err);
  });
```

**与其他语言对比**：
- **Python**: `hashlib.sha256(data).hexdigest()`
- **Java**: `MessageDigest.getInstance("SHA-256")`
- **Go**: `sha256.Sum256([]byte(data))`

## HMAC（哈希消息认证码）

### 基本 HMAC

```javascript
const crypto = require('crypto');

// 创建 HMAC
const secret = 'my-secret-key';
const hmac = crypto.createHmac('sha256', secret);
hmac.update('Hello, Node.js!');
const signature = hmac.digest('hex');

console.log('HMAC 签名:', signature);

// 验证 HMAC
function verifyHMAC(data, signature, secret) {
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(data);
  const expected = hmac.digest('hex');
  return crypto.timingSafeEqual(
    Buffer.from(signature, 'hex'),
    Buffer.from(expected, 'hex')
  );
}

const isValid = verifyHMAC('Hello, Node.js!', signature, secret);
console.log('验证结果:', isValid);
```

### 实际应用：API 签名

```javascript
const crypto = require('crypto');

class APISigner {
  constructor(secretKey) {
    this.secretKey = secretKey;
  }
  
  sign(data) {
    const hmac = crypto.createHmac('sha256', this.secretKey);
    hmac.update(JSON.stringify(data));
    return hmac.digest('hex');
  }
  
  verify(data, signature) {
    const expected = this.sign(data);
    return crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'),
      Buffer.from(expected, 'hex')
    );
  }
}

// 使用
const signer = new APISigner('my-secret-key');
const data = { userId: 123, action: 'transfer' };
const signature = signer.sign(data);

console.log('签名:', signature);
console.log('验证:', signer.verify(data, signature));
```

**与其他语言对比**：
- **Python**: `hmac.new(secret, data, hashlib.sha256).hexdigest()`
- **Java**: `Mac.getInstance("HmacSHA256")`
- **Go**: `hmac.New(sha256.New, secret)`

## 对称加密

### AES 加密解密

```javascript
const crypto = require('crypto');

// 生成密钥和 IV
const algorithm = 'aes-256-cbc';
const key = crypto.randomBytes(32);  // 256 位密钥
const iv = crypto.randomBytes(16);   // 128 位 IV

// 加密
function encrypt(text, key, iv) {
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}

// 解密
function decrypt(encrypted, key, iv) {
  const decipher = crypto.createDecipheriv(algorithm, key, iv);
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

// 使用
const plaintext = 'Hello, Node.js!';
const encrypted = encrypt(plaintext, key, iv);
console.log('加密后:', encrypted);

const decrypted = decrypt(encrypted, key, iv);
console.log('解密后:', decrypted);
```

### 密码派生（PBKDF2）

```javascript
const crypto = require('crypto');

// 从密码派生密钥
function deriveKey(password, salt) {
  return crypto.pbkdf2Sync(
    password,
    salt,
    100000,  // 迭代次数
    32,      // 密钥长度（字节）
    'sha256' // 哈希算法
  );
}

// 加密密码
function encryptPassword(password) {
  const salt = crypto.randomBytes(16);
  const key = deriveKey(password, salt);
  return {
    salt: salt.toString('hex'),
    key: key.toString('hex')
  };
}

// 验证密码
function verifyPassword(password, saltHex, keyHex) {
  const salt = Buffer.from(saltHex, 'hex');
  const key = deriveKey(password, salt);
  return crypto.timingSafeEqual(
    key,
    Buffer.from(keyHex, 'hex')
  );
}

// 使用
const password = 'my-secret-password';
const encrypted = encryptPassword(password);
console.log('加密的密码:', encrypted);

const isValid = verifyPassword(password, encrypted.salt, encrypted.key);
console.log('密码验证:', isValid);
```

**与其他语言对比**：
- **Python**: `cryptography.fernet` 或 `Crypto.Cipher.AES`
- **Java**: `Cipher.getInstance("AES/CBC/PKCS5Padding")`
- **Go**: `crypto/aes` 包

## 非对称加密

### RSA 加密解密

```javascript
const crypto = require('crypto');

// 生成密钥对
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
  publicKeyEncoding: {
    type: 'spki',
    format: 'pem'
  },
  privateKeyEncoding: {
    type: 'pkcs8',
    format: 'pem'
  }
});

// 加密（使用公钥）
function encryptRSA(data, publicKey) {
  return crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
      oaepHash: 'sha256'
    },
    Buffer.from(data)
  ).toString('base64');
}

// 解密（使用私钥）
function decryptRSA(encrypted, privateKey) {
  return crypto.privateDecrypt(
    {
      key: privateKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
      oaepHash: 'sha256'
    },
    Buffer.from(encrypted, 'base64')
  ).toString('utf8');
}

// 使用
const plaintext = 'Hello, Node.js!';
const encrypted = encryptRSA(plaintext, publicKey);
console.log('加密后:', encrypted);

const decrypted = decryptRSA(encrypted, privateKey);
console.log('解密后:', decrypted);
```

### 数字签名

```javascript
const crypto = require('crypto');

// 生成密钥对
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
  publicKeyEncoding: {
    type: 'spki',
    format: 'pem'
  },
  privateKeyEncoding: {
    type: 'pkcs8',
    format: 'pem'
  }
});

// 签名
function sign(data, privateKey) {
  const sign = crypto.createSign('sha256');
  sign.update(data);
  return sign.sign(privateKey, 'hex');
}

// 验证签名
function verify(data, signature, publicKey) {
  const verify = crypto.createVerify('sha256');
  verify.update(data);
  return verify.verify(publicKey, signature, 'hex');
}

// 使用
const data = 'Hello, Node.js!';
const signature = sign(data, privateKey);
console.log('签名:', signature);

const isValid = verify(data, signature, publicKey);
console.log('验证结果:', isValid);
```

**与其他语言对比**：
- **Python**: `cryptography.hazmat.primitives.asymmetric.rsa`
- **Java**: `KeyPairGenerator` 和 `Signature`
- **Go**: `crypto/rsa` 和 `crypto/ecdsa`

## 随机数生成

### 生成随机字节

```javascript
const crypto = require('crypto');

// 生成随机字节
const randomBytes = crypto.randomBytes(32);
console.log('随机字节:', randomBytes.toString('hex'));

// 生成随机整数
function randomInt(min, max) {
  return crypto.randomInt(min, max);
}

console.log('随机整数:', randomInt(1, 100));

// 生成随机 UUID（需要 crypto.randomUUID，Node.js 15.6.0+）
if (crypto.randomUUID) {
  const uuid = crypto.randomUUID();
  console.log('UUID:', uuid);
}
```

### 生成安全令牌

```javascript
const crypto = require('crypto');

function generateToken(length = 32) {
  return crypto.randomBytes(length).toString('hex');
}

function generateSecureToken() {
  return crypto.randomBytes(32).toString('base64url');
}

// 使用
const token = generateToken();
console.log('令牌:', token);

const secureToken = generateSecureToken();
console.log('安全令牌:', secureToken);
```

## 实际应用场景

### 场景 1：密码存储

```javascript
const crypto = require('crypto');

class PasswordManager {
  // 生成盐
  static generateSalt() {
    return crypto.randomBytes(16).toString('hex');
  }
  
  // 哈希密码
  static hashPassword(password, salt) {
    return crypto.pbkdf2Sync(
      password,
      salt,
      100000,
      64,
      'sha512'
    ).toString('hex');
  }
  
  // 验证密码
  static verifyPassword(password, hash, salt) {
    const hashToVerify = this.hashPassword(password, salt);
    return crypto.timingSafeEqual(
      Buffer.from(hash, 'hex'),
      Buffer.from(hashToVerify, 'hex')
    );
  }
  
  // 创建密码哈希
  static createPasswordHash(password) {
    const salt = this.generateSalt();
    const hash = this.hashPassword(password, salt);
    return { salt, hash };
  }
}

// 使用
const password = 'my-secret-password';
const { salt, hash } = PasswordManager.createPasswordHash(password);
console.log('盐:', salt);
console.log('哈希:', hash);

const isValid = PasswordManager.verifyPassword(password, hash, salt);
console.log('验证结果:', isValid);
```

### 场景 2：JWT 令牌

```javascript
const crypto = require('crypto');

class SimpleJWT {
  constructor(secret) {
    this.secret = secret;
  }
  
  // 编码 Base64URL
  static base64UrlEncode(str) {
    return Buffer.from(str)
      .toString('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  }
  
  // 解码 Base64URL
  static base64UrlDecode(str) {
    str = str.replace(/-/g, '+').replace(/_/g, '/');
    while (str.length % 4) {
      str += '=';
    }
    return Buffer.from(str, 'base64').toString();
  }
  
  // 生成签名
  sign(header, payload) {
    const data = `${header}.${payload}`;
    const hmac = crypto.createHmac('sha256', this.secret);
    hmac.update(data);
    return SimpleJWT.base64UrlEncode(hmac.digest('base64'));
  }
  
  // 生成令牌
  generate(payload, expiresIn = 3600) {
    const header = {
      alg: 'HS256',
      typ: 'JWT'
    };
    
    const exp = Math.floor(Date.now() / 1000) + expiresIn;
    const tokenPayload = { ...payload, exp };
    
    const encodedHeader = SimpleJWT.base64UrlEncode(JSON.stringify(header));
    const encodedPayload = SimpleJWT.base64UrlEncode(JSON.stringify(tokenPayload));
    const signature = this.sign(encodedHeader, encodedPayload);
    
    return `${encodedHeader}.${encodedPayload}.${signature}`;
  }
  
  // 验证令牌
  verify(token) {
    const parts = token.split('.');
    if (parts.length !== 3) {
      throw new Error('无效的令牌格式');
    }
    
    const [encodedHeader, encodedPayload, signature] = parts;
    const expectedSignature = this.sign(encodedHeader, encodedPayload);
    
    if (!crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    )) {
      throw new Error('无效的签名');
    }
    
    const payload = JSON.parse(SimpleJWT.base64UrlDecode(encodedPayload));
    
    if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {
      throw new Error('令牌已过期');
    }
    
    return payload;
  }
}

// 使用
const jwt = new SimpleJWT('my-secret-key');
const token = jwt.generate({ userId: 123, username: 'alice' }, 3600);
console.log('JWT 令牌:', token);

try {
  const payload = jwt.verify(token);
  console.log('令牌有效，载荷:', payload);
} catch (err) {
  console.error('验证失败:', err.message);
}
```

### 场景 3：文件完整性验证

```javascript
const crypto = require('crypto');
const fs = require('fs');

class FileIntegrityChecker {
  // 计算文件哈希
  static async calculateFileHash(filePath, algorithm = 'sha256') {
    return new Promise((resolve, reject) => {
      const hash = crypto.createHash(algorithm);
      const stream = fs.createReadStream(filePath);
      
      stream.on('data', chunk => hash.update(chunk));
      stream.on('end', () => resolve(hash.digest('hex')));
      stream.on('error', reject);
    });
  }
  
  // 验证文件完整性
  static async verifyFile(filePath, expectedHash, algorithm = 'sha256') {
    const actualHash = await this.calculateFileHash(filePath, algorithm);
    return crypto.timingSafeEqual(
      Buffer.from(actualHash, 'hex'),
      Buffer.from(expectedHash, 'hex')
    );
  }
}

// 使用
(async () => {
  const filePath = 'important-file.txt';
  const hash = await FileIntegrityChecker.calculateFileHash(filePath);
  console.log('文件哈希:', hash);
  
  // 保存哈希值，稍后验证
  const isValid = await FileIntegrityChecker.verifyFile(filePath, hash);
  console.log('文件完整性:', isValid ? '通过' : '失败');
})();
```

### 场景 4：安全通信

```javascript
const crypto = require('crypto');
const https = require('https');

// 生成自签名证书（仅用于开发）
function generateSelfSignedCert() {
  const { generateKeyPairSync } = crypto;
  
  const { publicKey, privateKey } = generateKeyPairSync('rsa', {
    modulusLength: 2048,
    publicKeyEncoding: {
      type: 'spki',
      format: 'pem'
    },
    privateKeyEncoding: {
      type: 'pkcs8',
      format: 'pem'
    }
  });
  
  // 注意：实际应用中应使用真实的 CA 签发的证书
  return { publicKey, privateKey };
}

// 使用 TLS 加密通信
const { publicKey, privateKey } = generateSelfSignedCert();

const options = {
  key: privateKey,
  cert: publicKey  // 实际应用中需要完整的证书链
};

const server = https.createServer(options, (req, res) => {
  res.writeHead(200);
  res.end('安全连接\n');
});

server.listen(443, () => {
  console.log('HTTPS 服务器运行在 https://localhost:443');
});
```

## 安全最佳实践

### 1. 使用 timingSafeEqual 防止时序攻击

```javascript
const crypto = require('crypto');

// ✅ 正确：使用 timingSafeEqual
function compareSecure(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  return crypto.timingSafeEqual(
    Buffer.from(a),
    Buffer.from(b)
  );
}

// ❌ 错误：直接比较可能受到时序攻击
function compareInsecure(a, b) {
  return a === b;  // 可能泄露信息
}
```

### 2. 密码存储

```javascript
// ✅ 正确：使用 PBKDF2 或 bcrypt
const crypto = require('crypto');

function hashPassword(password) {
  const salt = crypto.randomBytes(16);
  const hash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512');
  return { salt: salt.toString('hex'), hash: hash.toString('hex') };
}

// ❌ 错误：直接使用 MD5 或 SHA
function hashPasswordBad(password) {
  return crypto.createHash('md5').update(password).digest('hex');
}
```

### 3. 密钥管理

```javascript
// ✅ 正确：从环境变量读取密钥
const secretKey = process.env.SECRET_KEY || crypto.randomBytes(32).toString('hex');

// ❌ 错误：硬编码密钥
const secretKeyBad = 'my-secret-key';  // 不安全
```

## 总结

- **crypto 模块**提供了完整的加密功能
- 使用 **PBKDF2** 或 **bcrypt** 存储密码，不要使用简单哈希
- 使用 **timingSafeEqual** 防止时序攻击
- **对称加密**（AES）适合大量数据加密
- **非对称加密**（RSA）适合密钥交换和数字签名
- 使用 **随机数生成器**（`crypto.randomBytes`）生成安全令牌
- 密钥应存储在**环境变量**或**密钥管理服务**中，不要硬编码

