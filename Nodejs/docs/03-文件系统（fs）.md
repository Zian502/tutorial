# 文件系统（fs）

## fs 模块概述

`fs` 模块提供了与文件系统交互的 API，支持同步和异步两种操作方式。Node.js 还提供了基于 Promise 的版本 `fs.promises`。

### 与其他语言的对比

| 特性 | Node.js fs | Python os/io | Java java.nio.file | Go os/io |
|------|-----------|--------------|-------------------|----------|
| 异步支持 | 原生支持 | asyncio | CompletableFuture | goroutine |
| Promise 支持 | fs.promises | asyncio | CompletableFuture | 无 |
| 流支持 | fs.createReadStream | io.open | Files.newInputStream | os.Open |
| 文件监听 | fs.watch | watchdog | WatchService | fsnotify |

## 文件读取

### 异步读取

```javascript
const fs = require('fs');

// 回调方式
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('读取失败:', err);
    return;
  }
  console.log('文件内容:', data);
});

// Promise 方式
const fsPromises = require('fs').promises;

async function readFile() {
  try {
    const data = await fsPromises.readFile('file.txt', 'utf8');
    console.log('文件内容:', data);
  } catch (err) {
    console.error('读取失败:', err);
  }
}

// 读取二进制文件
async function readBinaryFile() {
  try {
    const buffer = await fsPromises.readFile('image.png');
    console.log('文件大小:', buffer.length, '字节');
  } catch (err) {
    console.error('读取失败:', err);
  }
}
```

### 同步读取

```javascript
const fs = require('fs');

try {
  const data = fs.readFileSync('file.txt', 'utf8');
  console.log('文件内容:', data);
} catch (err) {
  console.error('读取失败:', err);
}
```

**与其他语言对比**：
- **Python**: `open('file.txt').read()` 或 `pathlib.Path.read_text()`
- **Java**: `Files.readString(Path)` 或 `Files.readAllBytes(Path)`
- **Go**: `ioutil.ReadFile()` 或 `os.ReadFile()`

## 文件写入

### 异步写入

```javascript
const fs = require('fs');
const fsPromises = require('fs').promises;

// 回调方式
fs.writeFile('output.txt', 'Hello, Node.js!', 'utf8', (err) => {
  if (err) {
    console.error('写入失败:', err);
    return;
  }
  console.log('写入成功');
});

// Promise 方式
async function writeFile() {
  try {
    await fsPromises.writeFile('output.txt', 'Hello, Node.js!', 'utf8');
    console.log('写入成功');
  } catch (err) {
    console.error('写入失败:', err);
  }
}

// 追加写入
async function appendFile() {
  try {
    await fsPromises.appendFile('log.txt', '新日志条目\n', 'utf8');
    console.log('追加成功');
  } catch (err) {
    console.error('追加失败:', err);
  }
}
```

### 写入选项

```javascript
const fsPromises = require('fs').promises;

async function writeWithOptions() {
  try {
    await fsPromises.writeFile('output.txt', '内容', {
      encoding: 'utf8',
      mode: 0o666,        // 文件权限
      flag: 'w'          // 'w': 覆盖, 'a': 追加, 'wx': 排他写入
    });
  } catch (err) {
    console.error('写入失败:', err);
  }
}
```

**与其他语言对比**：
- **Python**: `open('file.txt', 'w').write()` 或 `pathlib.Path.write_text()`
- **Java**: `Files.writeString(Path, content)` 或 `Files.write(Path, bytes)`
- **Go**: `os.WriteFile()` 或 `ioutil.WriteFile()`

## 目录操作

### 创建目录

```javascript
const fsPromises = require('fs').promises;

// 创建单个目录
async function createDir() {
  try {
    await fsPromises.mkdir('new-directory');
    console.log('目录创建成功');
  } catch (err) {
    console.error('创建失败:', err);
  }
}

// 递归创建目录
async function createDirRecursive() {
  try {
    await fsPromises.mkdir('path/to/directory', { recursive: true });
    console.log('目录创建成功');
  } catch (err) {
    console.error('创建失败:', err);
  }
}
```

### 读取目录

```javascript
const fsPromises = require('fs').promises;

// 读取目录内容
async function readDir() {
  try {
    const files = await fsPromises.readdir('directory', { withFileTypes: true });
    
    for (const file of files) {
      if (file.isDirectory()) {
        console.log('目录:', file.name);
      } else {
        console.log('文件:', file.name);
      }
    }
  } catch (err) {
    console.error('读取失败:', err);
  }
}

// 递归读取目录
async function readDirRecursive(dir) {
  try {
    const entries = await fsPromises.readdir(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = require('path').join(dir, entry.name);
      
      if (entry.isDirectory()) {
        console.log('目录:', fullPath);
        await readDirRecursive(fullPath);  // 递归
      } else {
        console.log('文件:', fullPath);
      }
    }
  } catch (err) {
    console.error('读取失败:', err);
  }
}
```

### 删除目录

```javascript
const fsPromises = require('fs').promises;

// 删除空目录
async function removeDir() {
  try {
    await fsPromises.rmdir('directory');
    console.log('目录删除成功');
  } catch (err) {
    console.error('删除失败:', err);
  }
}

// 递归删除目录（Node.js 14.14.0+）
async function removeDirRecursive() {
  try {
    await fsPromises.rm('directory', { recursive: true, force: true });
    console.log('目录删除成功');
  } catch (err) {
    console.error('删除失败:', err);
  }
}
```

**与其他语言对比**：
- **Python**: `os.mkdir()`, `os.listdir()`, `os.rmdir()` 或 `pathlib.Path`
- **Java**: `Files.createDirectory()`, `Files.list()`, `Files.delete()`
- **Go**: `os.Mkdir()`, `os.ReadDir()`, `os.Remove()`

## 文件信息

### 获取文件状态

```javascript
const fsPromises = require('fs').promises;

async function getFileStats() {
  try {
    const stats = await fsPromises.stat('file.txt');
    
    console.log('文件大小:', stats.size, '字节');
    console.log('创建时间:', stats.birthtime);
    console.log('修改时间:', stats.mtime);
    console.log('访问时间:', stats.atime);
    console.log('是文件:', stats.isFile());
    console.log('是目录:', stats.isDirectory());
    console.log('是符号链接:', stats.isSymbolicLink());
  } catch (err) {
    console.error('获取信息失败:', err);
  }
}

// 检查文件是否存在
async function fileExists(filePath) {
  try {
    await fsPromises.access(filePath);
    return true;
  } catch {
    return false;
  }
}

// 或使用 stat
async function fileExists2(filePath) {
  try {
    await fsPromises.stat(filePath);
    return true;
  } catch {
    return false;
  }
}
```

**与其他语言对比**：
- **Python**: `os.stat()` 或 `pathlib.Path.stat()`
- **Java**: `Files.getFileAttributeView()` 或 `Files.readAttributes()`
- **Go**: `os.Stat()` 返回 `FileInfo`

## 文件流操作

### 创建读写流

```javascript
const fs = require('fs');

// 创建可读流
const readStream = fs.createReadStream('large-file.txt', {
  encoding: 'utf8',
  highWaterMark: 64 * 1024  // 64KB 缓冲区
});

readStream.on('data', (chunk) => {
  console.log('读取数据块:', chunk.length, '字节');
});

readStream.on('end', () => {
  console.log('读取完成');
});

// 创建可写流
const writeStream = fs.createWriteStream('output.txt', {
  encoding: 'utf8',
  flags: 'a'  // 追加模式
});

writeStream.write('第一行\n');
writeStream.write('第二行\n');
writeStream.end('最后一行\n');

writeStream.on('finish', () => {
  console.log('写入完成');
});
```

## 文件监听

### fs.watch

```javascript
const fs = require('fs');

// 监听文件变化
const watcher = fs.watch('file.txt', (eventType, filename) => {
  if (eventType === 'rename') {
    console.log('文件被重命名或删除');
  } else if (eventType === 'change') {
    console.log('文件内容发生变化');
  }
});

// 停止监听
setTimeout(() => {
  watcher.close();
  console.log('停止监听');
}, 60000);
```

### fs.watchFile（轮询方式）

```javascript
const fs = require('fs');

// 轮询方式监听（不推荐，性能较差）
fs.watchFile('file.txt', { interval: 1000 }, (curr, prev) => {
  if (curr.mtime !== prev.mtime) {
    console.log('文件被修改');
    console.log('当前大小:', curr.size);
    console.log('之前大小:', prev.size);
  }
});

// 停止监听
setTimeout(() => {
  fs.unwatchFile('file.txt');
  console.log('停止监听');
}, 60000);
```

**与其他语言对比**：
- **Python**: `watchdog` 库或 `inotify`（Linux）
- **Java**: `WatchService` API
- **Go**: `fsnotify` 包

## 文件操作

### 复制文件

```javascript
const fsPromises = require('fs').promises;

// 方式 1：使用 copyFile
async function copyFile() {
  try {
    await fsPromises.copyFile('source.txt', 'destination.txt');
    console.log('文件复制成功');
  } catch (err) {
    console.error('复制失败:', err);
  }
}

// 方式 2：使用流（适合大文件）
const fs = require('fs');

function copyFileStream(src, dst) {
  return new Promise((resolve, reject) => {
    const readStream = fs.createReadStream(src);
    const writeStream = fs.createWriteStream(dst);
    
    readStream.pipe(writeStream);
    
    readStream.on('error', reject);
    writeStream.on('error', reject);
    writeStream.on('finish', resolve);
  });
}
```

### 移动/重命名文件

```javascript
const fsPromises = require('fs').promises;

async function moveFile() {
  try {
    await fsPromises.rename('old-name.txt', 'new-name.txt');
    console.log('文件重命名成功');
  } catch (err) {
    console.error('重命名失败:', err);
  }
}
```

### 删除文件

```javascript
const fsPromises = require('fs').promises;

async function deleteFile() {
  try {
    await fsPromises.unlink('file.txt');
    console.log('文件删除成功');
  } catch (err) {
    console.error('删除失败:', err);
  }
}

// 删除文件（如果存在）
async function deleteFileIfExists(filePath) {
  try {
    await fsPromises.unlink(filePath);
  } catch (err) {
    if (err.code !== 'ENOENT') {  // 文件不存在不是错误
      throw err;
    }
  }
}
```

## 实际应用场景

### 场景 1：配置文件读取

```javascript
const fsPromises = require('fs').promises;
const path = require('path');

async function loadConfig(configPath) {
  try {
    const configFile = await fsPromises.readFile(configPath, 'utf8');
    const config = JSON.parse(configFile);
    return config;
  } catch (err) {
    if (err.code === 'ENOENT') {
      // 配置文件不存在，返回默认配置
      return getDefaultConfig();
    }
    throw err;
  }
}

function getDefaultConfig() {
  return {
    port: 3000,
    host: 'localhost',
    debug: false
  };
}
```

### 场景 2：日志文件管理

```javascript
const fsPromises = require('fs').promises;
const path = require('path');

class LogManager {
  constructor(logDir) {
    this.logDir = logDir;
  }
  
  async init() {
    // 确保日志目录存在
    await fsPromises.mkdir(this.logDir, { recursive: true });
  }
  
  async writeLog(level, message) {
    const logFile = path.join(
      this.logDir,
      `app-${new Date().toISOString().split('T')[0]}.log`
    );
    
    const logEntry = `[${new Date().toISOString()}] [${level}] ${message}\n`;
    
    await fsPromises.appendFile(logFile, logEntry, 'utf8');
  }
  
  async rotateLogs(maxDays = 7) {
    const files = await fsPromises.readdir(this.logDir);
    const now = Date.now();
    const maxAge = maxDays * 24 * 60 * 60 * 1000;
    
    for (const file of files) {
      if (file.endsWith('.log')) {
        const filePath = path.join(this.logDir, file);
        const stats = await fsPromises.stat(filePath);
        
        if (now - stats.mtime.getTime() > maxAge) {
          await fsPromises.unlink(filePath);
          console.log(`删除旧日志: ${file}`);
        }
      }
    }
  }
}

// 使用
(async () => {
  const logManager = new LogManager('./logs');
  await logManager.init();
  await logManager.writeLog('INFO', '应用启动');
  await logManager.rotateLogs(7);
})();
```

### 场景 3：文件上传处理

```javascript
const fsPromises = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class FileUploadHandler {
  constructor(uploadDir) {
    this.uploadDir = uploadDir;
  }
  
  async init() {
    await fsPromises.mkdir(this.uploadDir, { recursive: true });
  }
  
  async saveFile(fileStream, originalName) {
    // 生成唯一文件名
    const ext = path.extname(originalName);
    const hash = crypto.randomBytes(16).toString('hex');
    const fileName = `${hash}${ext}`;
    const filePath = path.join(this.uploadDir, fileName);
    
    // 保存文件
    const writeStream = require('fs').createWriteStream(filePath);
    fileStream.pipe(writeStream);
    
    return new Promise((resolve, reject) => {
      writeStream.on('finish', () => {
        resolve({
          fileName,
          filePath,
          size: require('fs').statSync(filePath).size
        });
      });
      writeStream.on('error', reject);
    });
  }
  
  async deleteFile(fileName) {
    const filePath = path.join(this.uploadDir, fileName);
    await fsPromises.unlink(filePath);
  }
}
```

### 场景 4：目录同步

```javascript
const fsPromises = require('fs').promises;
const path = require('path');

async function syncDirectories(src, dst) {
  // 确保目标目录存在
  await fsPromises.mkdir(dst, { recursive: true });
  
  // 读取源目录
  const entries = await fsPromises.readdir(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const dstPath = path.join(dst, entry.name);
    
    if (entry.isDirectory()) {
      // 递归同步子目录
      await syncDirectories(srcPath, dstPath);
    } else {
      // 复制文件
      await fsPromises.copyFile(srcPath, dstPath);
      console.log(`同步文件: ${entry.name}`);
    }
  }
}
```

### 场景 5：文件搜索

```javascript
const fsPromises = require('fs').promises;
const path = require('path');

async function findFiles(dir, pattern, options = {}) {
  const results = [];
  const { recursive = true, caseSensitive = false } = options;
  const regex = new RegExp(pattern, caseSensitive ? '' : 'i');
  
  async function search(currentDir) {
    try {
      const entries = await fsPromises.readdir(currentDir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);
        
        if (entry.isDirectory() && recursive) {
          await search(fullPath);
        } else if (entry.isFile() && regex.test(entry.name)) {
          results.push(fullPath);
        }
      }
    } catch (err) {
      // 忽略权限错误等
      if (err.code !== 'EACCES' && err.code !== 'EPERM') {
        throw err;
      }
    }
  }
  
  await search(dir);
  return results;
}

// 使用
(async () => {
  const files = await findFiles('.', '\\.js$', { recursive: true });
  console.log('找到的 JS 文件:', files);
})();
```

## 最佳实践

### 1. 使用 Promise 版本

```javascript
// ✅ 推荐：使用 Promise
const fsPromises = require('fs').promises;

async function readFile() {
  try {
    const data = await fsPromises.readFile('file.txt', 'utf8');
    return data;
  } catch (err) {
    console.error('读取失败:', err);
    throw err;
  }
}

// ❌ 避免：回调地狱
const fs = require('fs');
fs.readFile('file1.txt', (err, data1) => {
  if (err) return console.error(err);
  fs.readFile('file2.txt', (err, data2) => {
    if (err) return console.error(err);
    // ...
  });
});
```

### 2. 错误处理

```javascript
const fsPromises = require('fs').promises;

async function safeFileOperation() {
  try {
    const data = await fsPromises.readFile('file.txt', 'utf8');
    return data;
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.log('文件不存在');
      return null;
    } else if (err.code === 'EACCES') {
      console.log('权限不足');
      throw new Error('无法访问文件');
    } else {
      throw err;
    }
  }
}
```

### 3. 大文件使用流

```javascript
// ✅ 大文件使用流
const fs = require('fs');

function processLargeFile(filePath) {
  const readStream = fs.createReadStream(filePath);
  // 流式处理
  return readStream;
}

// ❌ 避免一次性读取大文件
async function processLargeFileBad(filePath) {
  const data = await fsPromises.readFile(filePath);  // 可能内存溢出
  // 处理数据
}
```

### 4. 路径处理

```javascript
const path = require('path');
const fsPromises = require('fs').promises;

// ✅ 使用 path.join
const filePath = path.join(__dirname, 'data', 'file.txt');

// ❌ 避免字符串拼接
const filePathBad = __dirname + '/data/file.txt';  // 跨平台问题
```

## 总结

- **fs 模块**提供了完整的文件系统操作 API
- 优先使用 **Promise 版本**（`fs.promises`）编写现代异步代码
- 大文件使用**流**而不是一次性读取
- 正确处理**错误**，特别是文件不存在和权限错误
- 使用 **path 模块**处理路径，保证跨平台兼容
- **文件监听**使用 `fs.watch` 而不是 `fs.watchFile`
- 目录操作使用 `recursive: true` 选项简化代码

