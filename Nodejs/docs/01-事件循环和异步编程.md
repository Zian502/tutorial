# 事件循环和异步编程

## 事件循环（Event Loop）概述

事件循环是 Node.js 的核心机制，它使 Node.js 能够在单线程中处理大量并发操作。

### 事件循环阶段

Node.js 事件循环包含以下阶段：

1. **Timer 阶段**：执行 `setTimeout()` 和 `setInterval()` 的回调
2. **Pending callbacks 阶段**：执行延迟到下一个循环迭代的 I/O 回调
3. **Idle, prepare 阶段**：内部使用
4. **Poll 阶段**：获取新的 I/O 事件，执行 I/O 相关回调
5. **Check 阶段**：执行 `setImmediate()` 的回调
6. **Close callbacks 阶段**：执行关闭回调（如 `socket.on('close')`）

### 与其他语言的对比

| 特性 | Node.js | Python (asyncio) | Java (NIO) | Go |
|------|---------|------------------|------------|-----|
| 并发模型 | 事件循环 | 事件循环 | Reactor 模式 | Goroutine |
| 线程模型 | 单线程（主线程） | 单线程（协程） | 多线程 | 多线程（M:N） |
| 非阻塞 I/O | 原生支持 | 通过 asyncio | 通过 NIO | 原生支持 |
| 回调风格 | Callback/Promise/Async | async/await | CompletableFuture | Channel |

## 异步编程模式

### 1. 回调函数（Callback）

回调函数是 Node.js 最基础的异步模式。

```javascript
const fs = require('fs');

// 回调函数模式
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('读取文件失败:', err);
    return;
  }
  console.log('文件内容:', data);
});

console.log('这行会先执行');
```

**与其他语言对比**：
- **Python**: 使用 `asyncio` 的 `async/await` 语法
- **Java**: 使用 `CompletableFuture` 或回调接口
- **Go**: 使用 goroutine 和 channel

**应用场景**：
- 文件 I/O 操作
- 网络请求
- 数据库查询

### 2. Promise

Promise 提供了更优雅的异步处理方式，避免了回调地狱。

```javascript
const fs = require('fs').promises;

// Promise 模式
fs.readFile('file.txt', 'utf8')
  .then(data => {
    console.log('文件内容:', data);
    return fs.readFile('file2.txt', 'utf8');
  })
  .then(data => {
    console.log('第二个文件:', data);
  })
  .catch(err => {
    console.error('读取失败:', err);
  });

// 使用 Promise.all 并行执行
Promise.all([
  fs.readFile('file1.txt', 'utf8'),
  fs.readFile('file2.txt', 'utf8'),
  fs.readFile('file3.txt', 'utf8')
])
  .then(results => {
    console.log('所有文件读取完成:', results);
  })
  .catch(err => {
    console.error('读取失败:', err);
  });
```

**与其他语言对比**：
- **Python**: `asyncio.gather()` 实现并行执行
- **Java**: `CompletableFuture.allOf()` 实现并行
- **Go**: 使用 `sync.WaitGroup` 或 channel

**应用场景**：
- 多个异步操作的链式调用
- 并行执行多个异步任务
- 错误处理

### 3. Async/Await

Async/Await 是 Promise 的语法糖，使异步代码看起来像同步代码。

```javascript
const fs = require('fs').promises;

// Async/Await 模式
async function readFiles() {
  try {
    const data1 = await fs.readFile('file1.txt', 'utf8');
    const data2 = await fs.readFile('file2.txt', 'utf8');
    console.log('文件1:', data1);
    console.log('文件2:', data2);
  } catch (err) {
    console.error('读取失败:', err);
  }
}

// 并行执行
async function readFilesParallel() {
  try {
    const [data1, data2, data3] = await Promise.all([
      fs.readFile('file1.txt', 'utf8'),
      fs.readFile('file2.txt', 'utf8'),
      fs.readFile('file3.txt', 'utf8')
    ]);
    console.log('所有文件读取完成');
  } catch (err) {
    console.error('读取失败:', err);
  }
}

readFiles();
```

**与其他语言对比**：
- **Python**: `async def` 和 `await` 语法相同
- **Java**: `CompletableFuture` 配合方法引用
- **Go**: 使用 goroutine 和 channel，语法不同但概念相似

**应用场景**：
- 复杂的异步逻辑
- 需要顺序执行的异步操作
- 错误处理更清晰的场景

## 定时器 API

### setTimeout 和 setInterval

```javascript
// setTimeout - 延迟执行
const timer1 = setTimeout(() => {
  console.log('3秒后执行');
}, 3000);

// 清除定时器
clearTimeout(timer1);

// setInterval - 定时重复执行
const timer2 = setInterval(() => {
  console.log('每秒执行一次');
}, 1000);

// 5秒后清除
setTimeout(() => {
  clearInterval(timer2);
  console.log('定时器已清除');
}, 5000);
```

### setImmediate

`setImmediate()` 在当前事件循环的 Check 阶段执行。

```javascript
console.log('1. 同步代码');

setTimeout(() => {
  console.log('3. setTimeout');
}, 0);

setImmediate(() => {
  console.log('4. setImmediate');
});

process.nextTick(() => {
  console.log('2. nextTick');
});

console.log('1.5. 同步代码结束');
// 输出顺序：
// 1. 同步代码
// 1.5. 同步代码结束
// 2. nextTick
// 3. setTimeout
// 4. setImmediate
```

### process.nextTick

`process.nextTick()` 在当前阶段执行完成后、下一个阶段开始前执行。

```javascript
console.log('开始');

process.nextTick(() => {
  console.log('nextTick 回调');
});

console.log('结束');

// 输出：
// 开始
// 结束
// nextTick 回调
```

**与其他语言对比**：
- **Python**: `asyncio.create_task()` 和 `asyncio.sleep()`
- **Java**: `ScheduledExecutorService` 实现定时任务
- **Go**: `time.After()` 和 `time.Ticker`

## 微任务和宏任务

### 执行顺序

```javascript
console.log('1. 同步代码');

setTimeout(() => {
  console.log('4. setTimeout (宏任务)');
}, 0);

Promise.resolve().then(() => {
  console.log('3. Promise (微任务)');
});

process.nextTick(() => {
  console.log('2. nextTick (微任务)');
});

console.log('1.5. 同步代码结束');

// 输出顺序：
// 1. 同步代码
// 1.5. 同步代码结束
// 2. nextTick (微任务)
// 3. Promise (微任务)
// 4. setTimeout (宏任务)
```

**执行优先级**：
1. 同步代码
2. `process.nextTick()` 回调
3. Promise 微任务
4. 宏任务（setTimeout、setImmediate、I/O 回调等）

## 实际应用场景

### 场景 1：并发请求处理

```javascript
const https = require('https');

async function fetchData(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => resolve(data));
      res.on('error', reject);
    }).on('error', reject);
  });
}

// 并发请求多个 API
async function fetchMultipleAPIs() {
  const urls = [
    'https://api.example.com/data1',
    'https://api.example.com/data2',
    'https://api.example.com/data3'
  ];
  
  try {
    const results = await Promise.all(
      urls.map(url => fetchData(url))
    );
    console.log('所有请求完成:', results);
  } catch (err) {
    console.error('请求失败:', err);
  }
}
```

### 场景 2：超时控制

```javascript
function withTimeout(promise, timeoutMs) {
  return Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('操作超时')), timeoutMs)
    )
  ]);
}

// 使用示例
async function fetchWithTimeout() {
  try {
    const data = await withTimeout(
      fetchData('https://api.example.com/slow'),
      5000  // 5秒超时
    );
    console.log('数据:', data);
  } catch (err) {
    console.error('错误:', err.message);
  }
}
```

### 场景 3：重试机制

```javascript
async function retry(fn, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === maxRetries - 1) throw err;
      console.log(`重试 ${i + 1}/${maxRetries}...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// 使用示例
async function fetchWithRetry() {
  try {
    const data = await retry(
      () => fetchData('https://api.example.com/unstable'),
      3,
      1000
    );
    console.log('成功获取数据:', data);
  } catch (err) {
    console.error('最终失败:', err);
  }
}
```

### 场景 4：批量处理

```javascript
async function batchProcess(items, batchSize, processor) {
  const results = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(item => processor(item))
    );
    results.push(...batchResults);
    console.log(`已处理 ${Math.min(i + batchSize, items.length)}/${items.length}`);
  }
  
  return results;
}

// 使用示例
async function processUsers() {
  const userIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  const results = await batchProcess(
    userIds,
    3,  // 每批处理 3 个
    async (userId) => {
      // 模拟异步处理
      await new Promise(resolve => setTimeout(resolve, 100));
      return `用户 ${userId} 处理完成`;
    }
  );
  
  console.log('所有用户处理完成:', results);
}
```

## 最佳实践

### 1. 避免回调地狱

```javascript
// ❌ 不好的做法
fs.readFile('file1.txt', (err, data1) => {
  if (err) return console.error(err);
  fs.readFile('file2.txt', (err, data2) => {
    if (err) return console.error(err);
    fs.writeFile('output.txt', data1 + data2, (err) => {
      if (err) return console.error(err);
      console.log('完成');
    });
  });
});

// ✅ 好的做法
async function processFiles() {
  try {
    const [data1, data2] = await Promise.all([
      fs.promises.readFile('file1.txt', 'utf8'),
      fs.promises.readFile('file2.txt', 'utf8')
    ]);
    await fs.promises.writeFile('output.txt', data1 + data2);
    console.log('完成');
  } catch (err) {
    console.error('错误:', err);
  }
}
```

### 2. 错误处理

```javascript
// ✅ 始终处理错误
async function safeAsyncOperation() {
  try {
    const result = await someAsyncOperation();
    return result;
  } catch (err) {
    // 记录错误
    console.error('操作失败:', err);
    // 返回默认值或重新抛出
    throw err;
  }
}
```

### 3. 避免阻塞事件循环

```javascript
// ❌ 阻塞事件循环
function heavyComputation() {
  let sum = 0;
  for (let i = 0; i < 10000000000; i++) {
    sum += i;
  }
  return sum;
}

// ✅ 使用 Worker Threads 处理 CPU 密集型任务
const { Worker, isMainThread, parentPort } = require('worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename);
  worker.on('message', (result) => {
    console.log('计算结果:', result);
  });
} else {
  // Worker 线程中的代码
  let sum = 0;
  for (let i = 0; i < 10000000000; i++) {
    sum += i;
  }
  parentPort.postMessage(sum);
}
```

## 总结

- **事件循环**是 Node.js 的核心，理解其阶段和执行顺序很重要
- **异步编程**有三种模式：回调、Promise、Async/Await
- **微任务**（nextTick、Promise）优先于**宏任务**（setTimeout、I/O）
- 使用 **Async/Await** 编写更清晰的异步代码
- 合理使用 **Promise.all** 实现并行处理
- 始终进行**错误处理**，避免未捕获的异常

