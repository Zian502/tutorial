# å¹¶å‘ç¼–ç¨‹

C++11 å¼•å…¥äº†æ ‡å‡†çº¿ç¨‹åº“ï¼Œä½¿å¾—å¤šçº¿ç¨‹ç¼–ç¨‹å˜å¾—æ›´åŠ ç®€å•å’Œå®‰å…¨ã€‚ç°ä»£ C++ æä¾›äº†çº¿ç¨‹ã€äº’æ–¥é”ã€æ¡ä»¶å˜é‡ã€åŸå­æ“ä½œç­‰å¹¶å‘å·¥å…·ã€‚

## çº¿ç¨‹

### åŸºæœ¬çº¿ç¨‹åˆ›å»º

```cpp
#include <iostream>
#include <thread>
#include <chrono>

void thread_function(int id) {
    for (int i = 0; i < 5; ++i) {
        std::cout << "Thread " << id << ": " << i << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {
    // åˆ›å»ºçº¿ç¨‹
    std::thread t1(thread_function, 1);
    std::thread t2(thread_function, 2);
    
    // ç­‰å¾…çº¿ç¨‹å®Œæˆ
    t1.join();
    t2.join();
    
    std::cout << "Main thread finished" << std::endl;
    
    return 0;
}
```

### Lambda å’Œçº¿ç¨‹

```cpp
#include <iostream>
#include <thread>
#include <vector>

int main() {
    std::vector<std::thread> threads;
    
    // ä½¿ç”¨ Lambda åˆ›å»ºçº¿ç¨‹
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back([i]() {
            std::cout << "Thread " << i << " running" << std::endl;
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹
    for (auto& t : threads) {
        t.join();
    }
    
    return 0;
}
```

### çº¿ç¨‹å‚æ•°ä¼ é€’

```cpp
#include <iostream>
#include <thread>
#include <string>

void print_message(const std::string& msg, int count) {
    for (int i = 0; i < count; ++i) {
        std::cout << msg << " " << i << std::endl;
    }
}

int main() {
    // ä¼ é€’å‚æ•°
    std::thread t(print_message, "Hello", 3);
    t.join();
    
    return 0;
}
```

## äº’æ–¥é”

### std::mutex

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>

std::mutex mtx;
int counter = 0;

void increment() {
    for (int i = 0; i < 10000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);  // è‡ªåŠ¨åŠ é”è§£é”
        counter++;
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(increment);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Counter: " << counter << std::endl;  // 50000
    
    return 0;
}
```

### å…¶ä»–äº’æ–¥é”ç±»å‹

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <shared_mutex>
#include <map>
#include <string>

// std::recursive_mutexï¼šå¯é‡å…¥é”
std::recursive_mutex rec_mtx;

void recursive_function(int depth) {
    std::lock_guard<std::recursive_mutex> lock(rec_mtx);
    if (depth > 0) {
        recursive_function(depth - 1);  // å¯ä»¥é€’å½’è°ƒç”¨
    }
}

// std::shared_mutexï¼šè¯»å†™é”ï¼ˆC++17ï¼‰
std::shared_mutex shared_mtx;
std::map<std::string, int> data;

void read_data(const std::string& key) {
    std::shared_lock<std::shared_mutex> lock(shared_mtx);  // å…±äº«é”
    // å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è¯»å–
    if (data.find(key) != data.end()) {
        std::cout << "Value: " << data[key] << std::endl;
    }
}

void write_data(const std::string& key, int value) {
    std::unique_lock<std::shared_mutex> lock(shared_mtx);  // ç‹¬å é”
    // åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥å†™å…¥
    data[key] = value;
}

int main() {
    recursive_function(5);
    
    std::thread reader1([&]() { read_data("key1"); });
    std::thread reader2([&]() { read_data("key1"); });
    std::thread writer([&]() { write_data("key1", 100); });
    
    reader1.join();
    reader2.join();
    writer.join();
    
    return 0;
}
```

## æ¡ä»¶å˜é‡

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex mtx;
std::condition_variable cv;
std::queue<int> queue;
bool finished = false;

void producer() {
    for (int i = 0; i < 10; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        queue.push(i);
        std::cout << "Produced: " << i << std::endl;
        cv.notify_one();  // é€šçŸ¥æ¶ˆè´¹è€…
        lock.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    {
        std::lock_guard<std::mutex> lock(mtx);
        finished = true;
    }
    cv.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []() { return !queue.empty() || finished; });
        
        if (queue.empty() && finished) {
            break;
        }
        
        if (!queue.empty()) {
            int value = queue.front();
            queue.pop();
            lock.unlock();
            std::cout << "Consumed: " << value << std::endl;
        }
    }
}

int main() {
    std::thread prod(producer);
    std::thread cons(consumer);
    
    prod.join();
    cons.join();
    
    return 0;
}
```

## åŸå­æ“ä½œ

### std::atomic

```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>

std::atomic<int> counter{0};

void increment() {
    for (int i = 0; i < 10000; ++i) {
        counter++;  // åŸå­æ“ä½œï¼Œæ— éœ€é”
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(increment);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Counter: " << counter << std::endl;  // 50000
    
    return 0;
}
```

### åŸå­æ“ä½œç±»å‹

```cpp
#include <iostream>
#include <atomic>
#include <thread>

int main() {
    // åŸºæœ¬åŸå­ç±»å‹
    std::atomic<int> atomic_int{0};
    std::atomic<bool> atomic_bool{false};
    std::atomic<double> atomic_double{0.0};
    
    // åŸå­æ“ä½œ
    int old_value = atomic_int.fetch_add(1);  // è¿”å›æ—§å€¼
    bool expected = false;
    bool success = atomic_bool.compare_exchange_strong(expected, true);
    
    // å†…å­˜é¡ºåº
    atomic_int.store(42, std::memory_order_relaxed);
    int value = atomic_int.load(std::memory_order_acquire);
    
    return 0;
}
```

## å¼‚æ­¥ç¼–ç¨‹

### std::asyncï¼ˆC++11ï¼‰

```cpp
#include <iostream>
#include <future>
#include <chrono>

int compute(int n) {
    // æ¨¡æ‹Ÿè€—æ—¶è®¡ç®—
    std::this_thread::sleep_for(std::chrono::seconds(1));
    return n * n;
}

int main() {
    // å¼‚æ­¥æ‰§è¡Œ
    std::future<int> future = std::async(std::launch::async, compute, 10);
    
    // åšå…¶ä»–å·¥ä½œ
    std::cout << "Doing other work..." << std::endl;
    
    // è·å–ç»“æœï¼ˆä¼šé˜»å¡ç›´åˆ°å®Œæˆï¼‰
    int result = future.get();
    std::cout << "Result: " << result << std::endl;
    
    return 0;
}
```

### std::promise å’Œ std::future

```cpp
#include <iostream>
#include <future>
#include <thread>

void set_value(std::promise<int>& prom) {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    prom.set_value(42);
}

int main() {
    std::promise<int> prom;
    std::future<int> fut = prom.get_future();
    
    std::thread t(set_value, std::ref(prom));
    
    std::cout << "Waiting for value..." << std::endl;
    int value = fut.get();
    std::cout << "Value: " << value << std::endl;
    
    t.join();
    
    return 0;
}
```

## çº¿ç¨‹æ± ï¼ˆC++17ï¼‰

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <future>

class ThreadPool {
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;

public:
    ThreadPool(size_t threads) : stop(false) {
        for (size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this]() {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(queue_mutex);
                        condition.wait(lock, [this]() { return stop || !tasks.empty(); });
                        if (stop && tasks.empty()) {
                            return;
                        }
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
        }
    }
    
    template<typename F>
    auto enqueue(F&& f) -> std::future<typename std::result_of<F()>::type> {
        using return_type = typename std::result_of<F()>::type;
        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::forward<F>(f)
        );
        std::future<return_type> res = task->get_future();
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            if (stop) {
                throw std::runtime_error("enqueue on stopped ThreadPool");
            }
            tasks.emplace([task]() { (*task)(); });
        }
        condition.notify_one();
        return res;
    }
    
    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread& worker : workers) {
            worker.join();
        }
    }
};

int main() {
    ThreadPool pool(4);
    
    std::vector<std::future<int>> results;
    for (int i = 0; i < 8; ++i) {
        results.emplace_back(pool.enqueue([i]() {
            return i * i;
        }));
    }
    
    for (auto& result : results) {
        std::cout << result.get() << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## å®è·µç»ƒä¹ 

### ç»ƒä¹  1ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

template<typename T>
class SafeQueue {
private:
    std::queue<T> queue;
    std::mutex mtx;
    std::condition_variable cv;

public:
    void push(const T& item) {
        std::lock_guard<std::mutex> lock(mtx);
        queue.push(item);
        cv.notify_one();
    }
    
    T pop() {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this]() { return !queue.empty(); });
        T item = queue.front();
        queue.pop();
        return item;
    }
};

int main() {
    SafeQueue<int> sq;
    
    std::thread producer([&sq]() {
        for (int i = 0; i < 10; ++i) {
            sq.push(i);
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    });
    
    std::thread consumer([&sq]() {
        for (int i = 0; i < 10; ++i) {
            int value = sq.pop();
            std::cout << "Consumed: " << value << std::endl;
        }
    });
    
    producer.join();
    consumer.join();
    
    return 0;
}
```

## ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”

| ç‰¹æ€§ | C++ | Java | Python | Go | Rust |
|------|-----|------|--------|-----|------|
| **çº¿ç¨‹** | std::thread | Thread | threading | goroutine | std::thread |
| **äº’æ–¥é”** | std::mutex | synchronized | Lock | sync.Mutex | Mutex |
| **æ¡ä»¶å˜é‡** | condition_variable | wait/notify | Condition | sync.Cond | Condvar |
| **åŸå­æ“ä½œ** | std::atomic | AtomicInteger | æ—  | sync/atomic | Atomic |
| **å¼‚æ­¥** | std::async | CompletableFuture | asyncio | goroutine | async/await |

## ä¸‹ä¸€æ­¥

ç°åœ¨ä½ å·²ç»æŒæ¡äº†å¹¶å‘ç¼–ç¨‹ï¼Œå¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

1. **[ç°ä»£ C++ ç‰¹æ€§](./12-ç°ä»£C++ç‰¹æ€§.md)** - äº†è§£æœ€æ–°ç‰¹æ€§
2. **[æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•](./14-æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•.md)** - å­¦ä¹ ä¼˜åŒ–æŠ€å·§
3. **[æ–‡ä»¶æ“ä½œå’Œ I/O](./13-æ–‡ä»¶æ“ä½œå’ŒIO.md)** - æŒæ¡æ–‡ä»¶å¤„ç†

ç¥ä½ å­¦ä¹ æ„‰å¿«ï¼ğŸ‰

