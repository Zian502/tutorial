# æ¨¡æ¿ç¼–ç¨‹

æ¨¡æ¿æ˜¯ C++ æ³›å‹ç¼–ç¨‹çš„åŸºç¡€ï¼Œå…è®¸ç¼–å†™ä¸ç±»å‹æ— å…³çš„ä»£ç ã€‚æ¨¡æ¿åœ¨ç¼–è¯‘æ—¶è¿›è¡Œå®ä¾‹åŒ–ï¼Œæä¾›äº†å¼ºå¤§çš„ä»£ç å¤ç”¨èƒ½åŠ›ã€‚

## å‡½æ•°æ¨¡æ¿

### åŸºæœ¬è¯­æ³•

```cpp
#include <iostream>

// å‡½æ•°æ¨¡æ¿å®šä¹‰
template<typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// å¤šä¸ªç±»å‹å‚æ•°
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    // æ˜¾å¼æŒ‡å®šç±»å‹
    std::cout << max_value<int>(3, 5) << std::endl;        // 5
    std::cout << max_value<double>(3.5, 2.1) << std::endl; // 3.5
    
    // ç±»å‹æ¨æ–­ï¼ˆæ¨èï¼‰
    std::cout << max_value(3, 5) << std::endl;             // 5
    std::cout << max_value(3.5, 2.1) << std::endl;         // 3.5
    
    // æ··åˆç±»å‹
    std::cout << add(3, 4.5) << std::endl;                 // 7.5
    
    return 0;
}
```

### æ¨¡æ¿ç‰¹åŒ–

```cpp
#include <iostream>
#include <cstring>

// é€šç”¨æ¨¡æ¿
template<typename T>
bool compare(const T& a, const T& b) {
    return a == b;
}

// ç‰¹åŒ–ï¼šé’ˆå¯¹ const char*
template<>
bool compare<const char*>(const char* const& a, const char* const& b) {
    return std::strcmp(a, b) == 0;
}

int main() {
    std::cout << std::boolalpha;
    std::cout << compare(3, 3) << std::endl;                    // true
    std::cout << compare("hello", "hello") << std::endl;        // trueï¼ˆä½¿ç”¨ç‰¹åŒ–ç‰ˆæœ¬ï¼‰
    
    return 0;
}
```

### éç±»å‹æ¨¡æ¿å‚æ•°

```cpp
#include <iostream>
#include <array>

// éç±»å‹æ¨¡æ¿å‚æ•°
template<typename T, size_t N>
void print_array(const std::array<T, N>& arr) {
    for (const auto& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
}

// ç¼–è¯‘æ—¶å¸¸é‡
template<int N>
int power_of_2() {
    return 1 << N;  // 2^N
}

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    print_array(arr);
    
    std::cout << "2^10 = " << power_of_2<10>() << std::endl;
    
    return 0;
}
```

## ç±»æ¨¡æ¿

### åŸºæœ¬è¯­æ³•

```cpp
#include <iostream>
#include <vector>

// ç±»æ¨¡æ¿
template<typename T>
class Stack {
private:
    std::vector<T> elements;

public:
    void push(const T& elem) {
        elements.push_back(elem);
    }
    
    void pop() {
        if (!elements.empty()) {
            elements.pop_back();
        }
    }
    
    T top() const {
        if (!elements.empty()) {
            return elements.back();
        }
        throw std::runtime_error("Stack is empty");
    }
    
    bool empty() const {
        return elements.empty();
    }
    
    size_t size() const {
        return elements.size();
    }
};

int main() {
    Stack<int> int_stack;
    int_stack.push(1);
    int_stack.push(2);
    int_stack.push(3);
    
    while (!int_stack.empty()) {
        std::cout << int_stack.top() << " ";
        int_stack.pop();
    }
    std::cout << std::endl;
    
    Stack<std::string> string_stack;
    string_stack.push("Hello");
    string_stack.push("World");
    
    return 0;
}
```

### æ¨¡æ¿æˆå‘˜å‡½æ•°

```cpp
#include <iostream>

template<typename T>
class Container {
private:
    T value;

public:
    Container(const T& v) : value(v) {}
    
    // æ¨¡æ¿æˆå‘˜å‡½æ•°
    template<typename U>
    void assign(const U& v) {
        value = static_cast<T>(v);
    }
    
    T get() const {
        return value;
    }
};

int main() {
    Container<int> c(10);
    c.assign(3.14);  // ä» double èµ‹å€¼ç»™ int
    std::cout << c.get() << std::endl;  // 3
    
    return 0;
}
```

### ç±»æ¨¡æ¿ç‰¹åŒ–

```cpp
#include <iostream>

// é€šç”¨æ¨¡æ¿
template<typename T>
class TypeInfo {
public:
    static const char* name() {
        return "Unknown";
    }
};

// ç‰¹åŒ–
template<>
class TypeInfo<int> {
public:
    static const char* name() {
        return "int";
    }
};

template<>
class TypeInfo<double> {
public:
    static const char* name() {
        return "double";
    }
};

template<>
class TypeInfo<std::string> {
public:
    static const char* name() {
        return "std::string";
    }
};

int main() {
    std::cout << TypeInfo<int>::name() << std::endl;
    std::cout << TypeInfo<double>::name() << std::endl;
    std::cout << TypeInfo<std::string>::name() << std::endl;
    
    return 0;
}
```

## å¯å˜å‚æ•°æ¨¡æ¿ï¼ˆC++11ï¼‰

### åŸºæœ¬è¯­æ³•

```cpp
#include <iostream>

// é€’å½’ç»ˆæ­¢å‡½æ•°
void print() {
    std::cout << std::endl;
}

// å¯å˜å‚æ•°æ¨¡æ¿
template<typename T, typename... Args>
void print(T first, Args... args) {
    std::cout << first << " ";
    print(args...);  // é€’å½’è°ƒç”¨
}

int main() {
    print(1, 2, 3, "hello", 3.14);
    // è¾“å‡ºï¼š1 2 3 hello 3.14
    
    return 0;
}
```

### æŠ˜å è¡¨è¾¾å¼ï¼ˆC++17ï¼‰

```cpp
#include <iostream>

// æŠ˜å è¡¨è¾¾å¼ï¼šç®€åŒ–å¯å˜å‚æ•°æ¨¡æ¿
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);  // å³æŠ˜å 
}

template<typename... Args>
void print_all(Args... args) {
    ((std::cout << args << " "), ...);  // å·¦æŠ˜å 
    std::cout << std::endl;
}

int main() {
    std::cout << sum(1, 2, 3, 4, 5) << std::endl;  // 15
    print_all(1, 2, 3, "hello", 3.14);
    
    return 0;
}
```

## æ¨¡æ¿å…ƒç¼–ç¨‹

### SFINAEï¼ˆSubstitution Failure Is Not An Errorï¼‰

```cpp
#include <iostream>
#include <type_traits>

// SFINAEï¼šæ›¿æ¢å¤±è´¥ä¸æ˜¯é”™è¯¯
template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
process(T value) {
    return value * 2;
}

template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, T>::type
process(T value) {
    return value * 1.5;
}

int main() {
    std::cout << process(10) << std::endl;      // 20
    std::cout << process(3.14) << std::endl;   // 4.71
    
    return 0;
}
```

### æ¦‚å¿µï¼ˆConceptsï¼ŒC++20ï¼‰

```cpp
#include <iostream>
#include <concepts>

// å®šä¹‰æ¦‚å¿µ
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

template<typename T>
concept Numeric = std::integral<T> || std::floating_point<T>;

// ä½¿ç”¨æ¦‚å¿µ
template<Addable T>
T add(T a, T b) {
    return a + b;
}

template<Numeric T>
T multiply(T a, T b) {
    return a * b;
}

int main() {
    std::cout << add(3, 4) << std::endl;        // 7
    std::cout << add(3.5, 4.2) << std::endl;    // 7.7
    
    std::cout << multiply(3, 4) << std::endl;  // 12
    std::cout << multiply(3.5, 4.2) << std::endl; // 14.7
    
    return 0;
}
```

## ç±»å‹ç‰¹å¾ï¼ˆType Traitsï¼‰

```cpp
#include <iostream>
#include <type_traits>

template<typename T>
void check_type() {
    std::cout << "Type: " << typeid(T).name() << std::endl;
    std::cout << "Is integral: " << std::is_integral_v<T> << std::endl;
    std::cout << "Is floating point: " << std::is_floating_point_v<T> << std::endl;
    std::cout << "Is pointer: " << std::is_pointer_v<T> << std::endl;
    std::cout << "Is const: " << std::is_const_v<T> << std::endl;
}

template<typename T>
void process_value(T value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integer: " << value << std::endl;
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "Float: " << value << std::endl;
    } else {
        std::cout << "Other type" << std::endl;
    }
}

int main() {
    check_type<int>();
    check_type<double>();
    
    process_value(42);
    process_value(3.14);
    
    return 0;
}
```

## å®è·µç»ƒä¹ 

### ç»ƒä¹  1ï¼šé€šç”¨å®¹å™¨

```cpp
#include <iostream>
#include <vector>

template<typename T>
class SimpleVector {
private:
    std::vector<T> data;

public:
    void push_back(const T& value) {
        data.push_back(value);
    }
    
    T& operator[](size_t index) {
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        return data[index];
    }
    
    size_t size() const {
        return data.size();
    }
    
    void print() const {
        for (const auto& elem : data) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    SimpleVector<int> int_vec;
    int_vec.push_back(1);
    int_vec.push_back(2);
    int_vec.push_back(3);
    int_vec.print();
    
    SimpleVector<std::string> str_vec;
    str_vec.push_back("Hello");
    str_vec.push_back("World");
    str_vec.print();
    
    return 0;
}
```

### ç»ƒä¹  2ï¼šç±»å‹å®‰å…¨çš„ max å‡½æ•°

```cpp
#include <iostream>
#include <type_traits>

template<typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type
safe_max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << safe_max(3, 5) << std::endl;        // 5
    std::cout << safe_max(3.5, 2.1) << std::endl;    // 3.5
    
    return 0;
}
```

## ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”

| ç‰¹æ€§ | C++ | Java | Python | Go | Rust |
|------|-----|------|--------|-----|------|
| **æ³›å‹** | æ¨¡æ¿ | æ³›å‹ | ç±»å‹æç¤º | æ—  | æ³›å‹ |
| **ç¼–è¯‘æ—¶** | âœ… | âŒ | âŒ | âŒ | âœ… |
| **ç‰¹åŒ–** | âœ… | âŒ | âŒ | âŒ | âŒ |
| **å¯å˜å‚æ•°** | âœ… (C++11) | âœ… | âœ… | âœ… | âœ… |
| **æ¦‚å¿µ** | âœ… (C++20) | âŒ | âŒ | âŒ | âœ… (Trait) |

## ä¸‹ä¸€æ­¥

ç°åœ¨ä½ å·²ç»æŒæ¡äº†æ¨¡æ¿ç¼–ç¨‹ï¼Œå¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

1. **[STL æ ‡å‡†åº“](./09-STLæ ‡å‡†åº“.md)** - å­¦ä¹ æ ‡å‡†åº“çš„ä½¿ç”¨
2. **[ç°ä»£ C++ ç‰¹æ€§](./12-ç°ä»£C++ç‰¹æ€§.md)** - äº†è§£ C++11/14/17/20/23 æ–°ç‰¹æ€§
3. **[æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•](./14-æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•.md)** - å­¦ä¹ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

ç¥ä½ å­¦ä¹ æ„‰å¿«ï¼ğŸ‰

