# æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•

æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•æ˜¯ C++ å¼€å‘ä¸­çš„é‡è¦æŠ€èƒ½ã€‚æœ¬ç« èŠ‚ä»‹ç»å¸¸ç”¨çš„ä¼˜åŒ–æŠ€å·§å’Œè°ƒè¯•æ–¹æ³•ã€‚

## æ€§èƒ½ä¼˜åŒ–

### ç¼–è¯‘å™¨ä¼˜åŒ–

```cpp
// ç¼–è¯‘é€‰é¡¹
// g++ -O2 -march=native source.cpp -o output
// -O2: æ¨èä¼˜åŒ–çº§åˆ«
// -O3: æœ€å¤§ä¼˜åŒ–ï¼ˆå¯èƒ½å¢åŠ ç¼–è¯‘æ—¶é—´ï¼‰
// -march=native: é’ˆå¯¹å½“å‰ CPU ä¼˜åŒ–
```

### å†…è”å‡½æ•°

```cpp
#include <iostream>

// å†…è”å‡½æ•°ï¼šé¿å…å‡½æ•°è°ƒç”¨å¼€é”€
inline int add(int a, int b) {
    return a + b;
}

// ç±»å†…å®šä¹‰çš„å‡½æ•°è‡ªåŠ¨å†…è”
class Math {
public:
    int multiply(int a, int b) {  // è‡ªåŠ¨å†…è”
        return a * b;
    }
};

int main() {
    int result = add(3, 4);  // å¯èƒ½è¢«å±•å¼€ä¸º: int result = 3 + 4;
    std::cout << result << std::endl;
    
    return 0;
}
```

### é¿å…ä¸å¿…è¦çš„å¤åˆ¶

```cpp
#include <iostream>
#include <vector>
#include <string>

// ä¸æ¨èï¼šå€¼ä¼ é€’ï¼ˆå¤åˆ¶ï¼‰
void process_by_value(std::vector<int> vec) {
    // vec æ˜¯å‰¯æœ¬ï¼Œå¤åˆ¶å¼€é”€å¤§
}

// æ¨èï¼šå¸¸é‡å¼•ç”¨ä¼ é€’
void process_by_reference(const std::vector<int>& vec) {
    // ä¸å¤åˆ¶ï¼Œåªä¼ é€’å¼•ç”¨
}

// æ¨èï¼šç§»åŠ¨è¯­ä¹‰ï¼ˆC++11ï¼‰
void process_by_move(std::vector<int>&& vec) {
    // ç§»åŠ¨ï¼Œä¸å¤åˆ¶
}

int main() {
    std::vector<int> large_vec(1000000);
    
    // ä½¿ç”¨å¼•ç”¨
    process_by_reference(large_vec);
    
    // ä½¿ç”¨ç§»åŠ¨
    process_by_move(std::move(large_vec));
    
    return 0;
}
```

### é¢„åˆ†é…å®¹å™¨å¤§å°

```cpp
#include <iostream>
#include <vector>

int main() {
    // ä¸æ¨èï¼šåŠ¨æ€å¢é•¿
    std::vector<int> vec1;
    for (int i = 0; i < 1000; ++i) {
        vec1.push_back(i);  // å¯èƒ½å¤šæ¬¡é‡æ–°åˆ†é…
    }
    
    // æ¨èï¼šé¢„åˆ†é…
    std::vector<int> vec2;
    vec2.reserve(1000);  // é¢„åˆ†é…ç©ºé—´
    for (int i = 0; i < 1000; ++i) {
        vec2.push_back(i);  // ä¸ä¼šé‡æ–°åˆ†é…
    }
    
    // æˆ–è€…ç›´æ¥æ„é€ 
    std::vector<int> vec3(1000);  // ç›´æ¥åˆ†é… 1000 ä¸ªå…ƒç´ 
    
    return 0;
}
```

### ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆé¿å…å†…å­˜æ³„æ¼

```cpp
#include <memory>

// ä¸æ¨èï¼šæ‰‹åŠ¨ç®¡ç†å†…å­˜
void bad_example() {
    int* ptr = new int(42);
    // å¦‚æœè¿™é‡ŒæŠ›å‡ºå¼‚å¸¸ï¼Œå†…å­˜æ³„æ¼
    delete ptr;
}

// æ¨èï¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
void good_example() {
    auto ptr = std::make_unique<int>(42);
    // å³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œä¹Ÿä¼šè‡ªåŠ¨é‡Šæ”¾
}
```

## æ€§èƒ½åˆ†æ

### æµ‹é‡æ‰§è¡Œæ—¶é—´

```cpp
#include <iostream>
#include <chrono>

template<typename Func>
void measure_time(const std::string& name, Func func) {
    auto start = std::chrono::high_resolution_clock::now();
    func();
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
        end - start
    );
    
    std::cout << name << " took " << duration.count() << " microseconds" << std::endl;
}

int main() {
    measure_time("Operation", []() {
        // è¦æµ‹é‡çš„ä»£ç 
        int sum = 0;
        for (int i = 0; i < 1000000; ++i) {
            sum += i;
        }
    });
    
    return 0;
}
```

### ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·

```bash
# ä½¿ç”¨ gprof
g++ -pg -O2 source.cpp -o output
./output
gprof output gmon.out > analysis.txt

# ä½¿ç”¨ perf (Linux)
perf record ./output
perf report

# ä½¿ç”¨ Valgrind
valgrind --tool=callgrind ./output
kcachegrind callgrind.out.*
```

## è°ƒè¯•æŠ€å·§

### ä½¿ç”¨è°ƒè¯•å™¨ï¼ˆGDBï¼‰

```bash
# ç¼–è¯‘æ—¶æ·»åŠ è°ƒè¯•ä¿¡æ¯
g++ -g -o program source.cpp

# å¯åŠ¨ GDB
gdb ./program

# å¸¸ç”¨å‘½ä»¤
# break main          # è®¾ç½®æ–­ç‚¹
# run                 # è¿è¡Œç¨‹åº
# next                # ä¸‹ä¸€è¡Œ
# step                # è¿›å…¥å‡½æ•°
# print variable      # æ‰“å°å˜é‡
# backtrace           # æŸ¥çœ‹è°ƒç”¨æ ˆ
# continue            # ç»§ç»­æ‰§è¡Œ
```

### æ–­è¨€

```cpp
#include <iostream>
#include <cassert>

int divide(int a, int b) {
    assert(b != 0 && "Division by zero!");  // è°ƒè¯•æ—¶æ£€æŸ¥
    return a / b;
}

int main() {
    // åœ¨ Debug æ¨¡å¼ä¸‹ï¼Œæ–­è¨€ä¼šæ£€æŸ¥
    // åœ¨ Release æ¨¡å¼ä¸‹ï¼Œæ–­è¨€é€šå¸¸è¢«ç¦ç”¨
    int result = divide(10, 2);
    std::cout << result << std::endl;
    
    return 0;
}
```

### æ—¥å¿—è¾“å‡º

```cpp
#include <iostream>
#include <fstream>
#include <chrono>
#include <iomanip>

class Logger {
private:
    std::ofstream log_file;
    
public:
    Logger(const std::string& filename) {
        log_file.open(filename, std::ios::app);
    }
    
    template<typename... Args>
    void log(Args... args) {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        
        log_file << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S")
                 << " ";
        ((log_file << args << " "), ...);
        log_file << std::endl;
    }
};

int main() {
    Logger logger("debug.log");
    logger.log("Program started");
    logger.log("Processing data:", 42);
    
    return 0;
}
```

## å†…å­˜è°ƒè¯•

### Valgrind

```bash
# æ£€æµ‹å†…å­˜æ³„æ¼
valgrind --leak-check=full ./program

# æ£€æµ‹æœªåˆå§‹åŒ–å†…å­˜
valgrind --track-origins=yes ./program

# æ£€æµ‹è¶Šç•Œè®¿é—®
valgrind ./program
```

### AddressSanitizer

```bash
# ç¼–è¯‘æ—¶å¯ç”¨ AddressSanitizer
g++ -fsanitize=address -g source.cpp -o output

# è¿è¡Œç¨‹åºï¼Œä¼šè‡ªåŠ¨æ£€æµ‹å†…å­˜é”™è¯¯
./output
```

## æœ€ä½³å®è·µ

### 1. ä½¿ç”¨ const å’Œ constexpr

```cpp
// constï¼šè¿è¡Œæ—¶å¸¸é‡
const int max_size = 100;

// constexprï¼šç¼–è¯‘æ—¶å¸¸é‡ï¼ˆC++11ï¼‰
constexpr int buffer_size = 1024;

// constexpr å‡½æ•°ï¼šç¼–è¯‘æ—¶è®¡ç®—
constexpr int square(int x) {
    return x * x;
}

constexpr int result = square(5);  // ç¼–è¯‘æ—¶è®¡ç®—
```

### 2. é¿å…è™šå‡½æ•°è°ƒç”¨å¼€é”€ï¼ˆå¦‚æœå¯èƒ½ï¼‰

```cpp
// å¦‚æœä¸éœ€è¦å¤šæ€ï¼Œé¿å…ä½¿ç”¨è™šå‡½æ•°
class FastClass {
public:
    void process() {  // éè™šå‡½æ•°ï¼Œæ›´å¿«
        // ...
    }
};
```

### 3. ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰

```cpp
#include <vector>
#include <string>

std::vector<std::string> get_data() {
    std::vector<std::string> data;
    // ... å¡«å…… data
    return data;  // è‡ªåŠ¨ç§»åŠ¨ï¼Œä¸å¤åˆ¶
}

int main() {
    auto data = get_data();  // ç§»åŠ¨æ„é€ ï¼Œé«˜æ•ˆ
    return 0;
}
```

### 4. ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„

```cpp
// æ¨èï¼šè¿ç»­å†…å­˜å¸ƒå±€
std::vector<int> vec;  // æ•°æ®è¿ç»­å­˜å‚¨

// ä¸æ¨èï¼šæŒ‡é’ˆè·³è·ƒ
std::list<int> lst;  // æ•°æ®åˆ†æ•£å­˜å‚¨
```

## æ€§èƒ½æµ‹è¯•

### åŸºå‡†æµ‹è¯•

```cpp
#include <iostream>
#include <chrono>
#include <vector>
#include <algorithm>

void benchmark() {
    const int size = 1000000;
    std::vector<int> vec(size);
    std::iota(vec.begin(), vec.end(), 0);
    
    auto start = std::chrono::high_resolution_clock::now();
    std::sort(vec.begin(), vec.end());
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
        end - start
    );
    
    std::cout << "Sort took " << duration.count() << " ms" << std::endl;
}

int main() {
    benchmark();
    return 0;
}
```

## æ€»ç»“

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

- [ ] ä½¿ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–é€‰é¡¹ï¼ˆ-O2ï¼‰
- [ ] é¿å…ä¸å¿…è¦çš„å¤åˆ¶ï¼ˆä½¿ç”¨å¼•ç”¨å’Œç§»åŠ¨ï¼‰
- [ ] é¢„åˆ†é…å®¹å™¨å¤§å°
- [ ] ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†å†…å­˜
- [ ] å†…è”å°å‡½æ•°
- [ ] ä½¿ç”¨ const å’Œ constexpr
- [ ] é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
- [ ] é¿å…è™šå‡½æ•°è°ƒç”¨ï¼ˆå¦‚æœä¸éœ€è¦å¤šæ€ï¼‰
- [ ] ä½¿ç”¨ç¼“å­˜å‹å¥½çš„æ•°æ®å¸ƒå±€
- [ ] è¿›è¡Œæ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•

### è°ƒè¯•æ£€æŸ¥æ¸…å•

- [ ] ä½¿ç”¨è°ƒè¯•å™¨ï¼ˆGDB/LLDBï¼‰
- [ ] æ·»åŠ æ–­è¨€æ£€æŸ¥
- [ ] ä½¿ç”¨æ—¥å¿—è®°å½•
- [ ] ä½¿ç”¨å†…å­˜æ£€æŸ¥å·¥å…·ï¼ˆValgrind/AddressSanitizerï¼‰
- [ ] æ£€æŸ¥æœªå®šä¹‰è¡Œä¸º
- [ ] éªŒè¯è¾¹ç•Œæ¡ä»¶

## ä¸‹ä¸€æ­¥

æ­å–œä½ å®Œæˆäº† C++ å­¦ä¹ æŒ‡å—ï¼ç°åœ¨ä½ å¯ä»¥ï¼š

1. å›é¡¾ä¹‹å‰ç« èŠ‚ï¼Œå·©å›ºçŸ¥è¯†
2. å°è¯•å®Œæˆå®é™…é¡¹ç›®
3. é˜…è¯» C++ æ ‡å‡†åº“æºç 
4. å‚ä¸ C++ ç¤¾åŒºè®¨è®º

ç¥ä½ ç¼–ç¨‹æ„‰å¿«ï¼ğŸ‰

